(eval-when (:compile-toplevel :load-toplevel :execute)
  (load "test-util")
  (load "../radix-heap.lisp")
  (load "../abstract-heap.lisp"))

(use-package :test-util)

(define-binary-heap bheap
  :order #'<
  :element-type fixnum)

(with-test (:name radix-heap/manual)
  (let ((h (make-radix-heap)))
    (assert (rheap-empty-p h))
    (assert (= 0 (rheap-count h)))
    (rheap-push 15 h)
    (assert (not (rheap-empty-p h)))
    (dolist (x '(6 18 220 270 9 11))
      (rheap-push x h))
    (assert (= 6 (rheap-pop h)))
    (rheap-push 10 h)
    (assert (= 7 (rheap-count h)))
    (assert (equal '(9 10 11 15 18 220 270)
                   (loop repeat 7 collect (rheap-pop h))))
    (signals rheap-not-monotone-error (rheap-push 269 h))
    (signals rheap-empty-error (rheap-pop h))
    (rheap-push 270 h)
    (rheap-push 270 h)
    (assert (= 270 (rheap-pop h)))
    (assert (= 270 (rheap-pop h)))
    (assert (rheap-empty-p h))))

(defparameter *state* (sb-ext:seed-random-state 0))

(with-test (:name radix-heap/random)
  (dotimes (_ 100)
    (let ((rheap (make-radix-heap))
          (bheap (make-bheap 1000)))
      (dotimes (_ 1000)
        (if (or (zerop (rheap-count rheap)) (= (random 2 *state*) 1))
            (let* ((lowest (rheap-lowest rheap))
                   (rand (random most-positive-fixnum *state*))
                   (delta (logand (- (ash 1 (random 15 *state*)) 1) rand)))
              (rheap-push (+ lowest delta) rheap)
              (bheap-push (+ lowest delta) bheap))
            (assert (= (rheap-pop rheap) (bheap-pop bheap))))))))
