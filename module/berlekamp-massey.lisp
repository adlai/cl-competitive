(defpackage :cp/berlekamp-massey
  (:use :cl :cp/mod-inverse)
  (:export #:find-linear-recurrence #:find-rational-gf #:rminpoly-linear-map))
(in-package :cp/berlekamp-massey)

(defun find-linear-recurrence (vector modulus)
  "Returns a vector expressing the linear recurrence of a given sequence.

\(find-linear-recurrence #(0 1 2 5 12 29)) |-> #(2 1)
This means the recurrence relation is a(i) = 2a(i-1)+a(i-2) and the
denominator of generating function is 1-2x-x^2."
  (declare (optimize (speed 3))
           (vector vector)
           ((unsigned-byte 31) modulus))
  (let* ((vector (coerce vector '(simple-array (unsigned-byte 31) (*))))
         (n (length vector))
         (c (make-array 1 :element-type '(unsigned-byte 31) :initial-element (- modulus 1)))
         (c2 (make-array 1 :element-type '(unsigned-byte 31) :initial-element (- modulus 1)))
         (r2 1)
         (i2 -1))
    (declare ((simple-array (unsigned-byte 31) (*)) c c2)
             ((unsigned-byte 31) r2)
             (fixnum i2))
    (dotimes (i n)
      (let ((r 0)
            (len (length c)))
        (declare ((unsigned-byte 31) r))
        (dotimes (j len)
          (setq r (mod (+ r (* (aref c j) (aref vector (- i j))))
                       modulus)))
        (unless (zerop r)
          (let ((coef (- modulus (mod (* r (mod-inverse r2 modulus)) modulus)))
                (len2 (length c2)))
            (declare ((unsigned-byte 31) coef))
            (if (>= (- len i) (- len2 i2))
                (dotimes (j len2)
                  (let ((dest (- (+ j i) i2)))
                    (setf (aref c dest)
                          (mod (+ (aref c dest) (* (aref c2 j) coef))
                               modulus))))
                (let ((tmp (copy-seq c)))
                  (setq c (adjust-array c (the (mod #.array-dimension-limit)
                                               (- (+ len2 i) i2))))
                  (dotimes (j len2)
                    (let ((dest (- (+ j i) i2)))
                      (setf (aref c dest)
                            (mod (+ (aref c dest) (* (aref c2 j) coef))
                                 modulus))))
                  (setq c2 tmp
                        i2 i
                        r2 r)))))))
    (subseq c 1)))

(declaim (ftype (function * (values (simple-array (unsigned-byte 31) (*)) &optional))
                rminpoly-scalar))
(defun rminpoly-scalar (vector modulus)
  (declare (optimize (speed 3))
           ((unsigned-byte 31) modulus))
  (let ((res (concatenate '(simple-array (unsigned-byte 31) (*))
                          #(1)
                          (find-linear-recurrence vector modulus))))
    (loop for i from 1 below (length res)
          do (setf (aref res i) (mod (- (aref res i)) modulus)))
    res))

(declaim (inline find-rational-gf))
(defun find-rational-gf (vector modulus)
  "Returns the numerator and the denominator of a rational function, which is
the OGF of the given sequence."
  (declare (vector vector)
           ((unsigned-byte 31) modulus))
  (let* ((vector (coerce vector '(simple-array (unsigned-byte 31) (*))))
         (denom (rminpoly-scalar vector modulus))
         (len (- (length denom) 1))
         (num (make-array len :element-type '(unsigned-byte 31))))
    (loop for i from 1 below (length denom)
          unless (zerop (aref denom i))
          do (setf (aref denom i) (- modulus (aref denom i))))
    (dotimes (d len)
      ;; 0 <= i < len, 0 <= j < len
      (loop with coef of-type (unsigned-byte 31) = 0
            for i from (max 0 (- d (- len 1))) to (min d (- len 1))
            for j = (- d i)
            do (setq coef (mod (+ coef (* (aref denom i) (aref vector j))) modulus))
            finally (setf (aref num d) coef)))
    (values num denom)))

(declaim (inline make-random-polynomial))
(defun make-random-polynomial (length modulus)
  (let ((res (make-array length :element-type '(unsigned-byte 31))))
    (dotimes (i length)
      (setf (aref res i) (random modulus)))
    res))

(declaim (ftype (function * (values (simple-array (unsigned-byte 31) (*)) &optional))
                rminpoly-vector))
(defun rminpoly-vector (vectors modulus)
  (declare (optimize (speed 3))
           (vector vectors)
           ((unsigned-byte 31) modulus))
  (let* ((len (length vectors))
         (dim (length (the vector (aref vectors 0))))
         (init-term (make-random-polynomial dim modulus))
         (scalars (make-array len :element-type '(unsigned-byte 31) :initial-element 0)))
    (labels ((dot (v1 v2)
               (declare ((simple-array (unsigned-byte 31) (*)) v1 v2))
               (let ((res 0))
                 (declare ((unsigned-byte 31) res))
                 (loop for x1 across v1
                       for x2 across v2
                       do (setq res (mod (+ res (* x1 x2)) modulus)))
                 res)))
      (dotimes (i len)
        (setf (aref scalars i) (dot (aref vectors i) init-term)))
      (rminpoly-scalar scalars modulus))))

(declaim (inline rminpoly-linear-map))
(defun rminpoly-linear-map (function dim modulus)
  (declare ((unsigned-byte 31) modulus dim))
  (let ((term (make-random-polynomial dim modulus))
        (vectors (make-array (* 2 dim) :element-type t)))
    (dotimes (i (length vectors))
      (setf (aref vectors i) term
            term (funcall function term)))
    (rminpoly-vector vectors modulus)))
