(defpackage :cp/mod-convolve
  (:use :cl :cp/fft-real)
  (:export #:mod-convolve)
  (:import-from :cp/fft-real #:%adjust-array #:%pointwise-mult!))
(in-package :cp/mod-convolve)

(deftype uint () '(unsigned-byte 31))
(defconstant +half+ 15)

(declaim (ftype (function * (values fft-vector &optional)) %to-fft-vector))
(defun %to-fft-vector (vector new-length hi-p)
  (declare (optimize (speed 3))
           ((simple-array uint (*)) vector)
           ((mod #.array-dimension-limit) new-length))
  (let ((result (make-array new-length
                            :element-type 'fft-float
                            :initial-element (coerce 0 'fft-float))))
    (if hi-p
        (dotimes (i (length vector))
          (setf (aref result i)
                (coerce (ash (aref vector i) #.(- +half+))
                        'fft-float)))
        (dotimes (i (length vector))
          (setf (aref result i)
                (coerce (logand #.(- (ash 1 +half+) 1)
                                (aref vector i))
                        'fft-float))))
    result))

(declaim (inline mod-convolve))
(defun mod-convolve (vector1 vector2 modulus)
  (declare (optimize (speed 3))
           (vector vector1 vector2)
           (uint modulus))
  (let ((len1 (length vector1))
        (len2 (length vector2)))
    (when (or (zerop len1) (zerop len2))
      (return-from mod-convolve (make-array 0 :element-type 'uint)))
    (let* ((vector1 (coerce vector1 '(simple-array uint (*))))
           (vector2 (coerce vector2 '(simple-array uint (*))))
           (mul-len (max 0 (- (+ len1 len2) 1)))
           ;; power of two ceiling
           (n (ash 1 (integer-length (max 0 (- mul-len 1)))))
           (v1-lo (dft! (%to-fft-vector vector1 n nil)))
           (v1-hi (dft! (%to-fft-vector vector1 n t)))
           (v2-lo (dft! (%to-fft-vector vector2 n nil)))
           (v2-hi (dft! (%to-fft-vector vector2 n t)))
           (tmp (make-array n
                            :element-type 'fft-float
                            :initial-element (coerce 0 'fft-float)))
           (res (make-array mul-len :element-type 'uint :initial-element 0)))
      (declare ((mod #.array-dimension-limit) mul-len))
      (labels ((proc! (v1 v2)
                 (declare (fft-vector v1 v2))
                 (fill tmp (coerce 0 'fft-float))
                 (%pointwise-mult! v1 v2 tmp)
                 (inverse-dft! tmp))
               (mod+ (x y) (mod (+ x y) modulus))
               (%round (x)
                 (declare ((fft-float #.(coerce most-negative-fixnum 'fft-float)
                                      #.(coerce most-positive-fixnum 'fft-float))
                           x))
                 (mod (round x) modulus)))
        (proc! v1-lo v2-lo)
        (dotimes (i mul-len)
          (setf (aref res i) (%round (aref tmp i))))
        (proc! v1-lo v2-hi)
        (dotimes (i mul-len)
          (setf (aref res i)
                (mod+ (aref res i) (mod (ash (%round (aref tmp i)) +half+)
                                        modulus))))
        (proc! v1-hi v2-lo)
        (dotimes (i mul-len)
          (setf (aref res i)
                (mod+ (aref res i) (mod (ash (%round (aref tmp i)) +half+)
                                        modulus))))
        (proc! v1-hi v2-hi)
        (dotimes (i mul-len)
          (setf (aref res i)
                (mod+ (aref res i) (mod (ash (%round (aref tmp i)) #.(* 2 +half+))
                                        modulus))))
        res))))
