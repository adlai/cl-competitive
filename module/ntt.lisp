(defpackage :cp/ntt
  (:use :cl :cp/mod-inverse)
  (:export #:define-ntt #:check-ntt-vector #:ntt-int #:ntt-vector)
  (:documentation
   "Provides fast number theoretic transform.

Reference:
https://github.com/ei1333/library/blob/master/math/fft/number-theoretic-transform-friendly-mod-int.cpp
https://github.com/atcoder/ac-library/tree/master/atcoder"))
(in-package :cp/ntt)

(deftype ntt-int () '(unsigned-byte 31))
(deftype ntt-vector () '(simple-array ntt-int (*)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (declaim (inline %tzcount))
  (defun %tzcount (x)
    "Returns the number of the trailing zero bits. Note that (%TZCOUNT 0) = -1."
    (- (integer-length (logand x (- x))) 1))
  (defun %mod-power (base exp modulus)
    (declare (ntt-int base exp modulus))
    (let ((res 1))
      (declare (ntt-int res))
      (loop while (> exp 0)
            when (oddp exp)
            do (setq res (mod (* res base) modulus))
            do (setq base (mod (* base base) modulus)
                     exp (ash exp -1)))
      res))
  (defun %mod-inverse (x modulus)
    (%mod-power x (- modulus 2) modulus))
  (defun %calc-generator (modulus)
    "MODULUS must be prime."
    (declare (ntt-int modulus))
    (assert (>= modulus 2))
    (case modulus
      (2 1)
      (167772161 3)
      (469762049 3)
      (754974721 11)
      (998244353 3)
      (otherwise
       (let ((divs (make-array 20 :element-type 'ntt-int :initial-element 0))
             (end 1)
             (x (floor (- modulus 1) 2)))
         (declare ((integer 0 #.most-positive-fixnum) x))
         (setf (aref divs 0) 2)
         (loop while (evenp x)
               do (setq x (floor x 2)))
         (loop for i of-type ntt-int from 3 by 2
               while (<= (* i i) x)
               when (zerop (mod x i))
               do (setf (aref divs end) i)
                  (incf end)
                  (loop while (zerop (mod x i))
                        do (setq x (floor x i))))
         (when (> x 1)
           (setf (aref divs end) x)
           (incf end))
         (loop for g of-type ntt-int from 2
               do (dotimes (i end (return-from %calc-generator g))
                    (when (= 1 (%mod-power g (floor (- modulus 1) (aref divs i)) modulus))
                      (return)))))))))

(declaim (ftype (function * (values ntt-vector &optional)) %adjust-array))
(defun %adjust-array (vector length)
  "This function always copies VECTOR. (ANSI CL doesn't state whether
CL:ADJUST-ARRAY should copy the given array or not.)"
  (declare (optimize (speed 3))
           (vector vector)
           ((mod #.array-dimension-limit) length))
  (let ((vector (coerce vector 'ntt-vector)))
    (if (= (length vector) length)
        (copy-seq vector)
        (let ((res (make-array length :element-type 'ntt-int :initial-element 0)))
          (replace res vector)
          res))))

(defun check-ntt-vector (vector)
  (declare (optimize (speed 3))
           (vector vector))
  (let ((len (length vector)))
    (assert (and (zerop (logand len (- len 1))) ; power of two
                 (typep len 'ntt-int)))))

(defmacro define-ntt (modulus &key ntt inverse-ntt convolve &environment env)
  (assert (constantp modulus env))
  (let* ((modulus #+sbcl (sb-int:constant-form-value modulus env) #-sbcl modulus)
         (ntt (or ntt (intern "NTT!")))
         (inverse-ntt (or inverse-ntt (intern "INVERSE-NTT!")))
         (convolve (or convolve (intern "CONVOLVE")))
         (ntt-base (gensym "*NTT-BASE*"))
         (ntt-inv-base (gensym "*NTT-INV-BASE*"))
         (base-size (%tzcount (- modulus 1)))
         (root (%calc-generator modulus))
         (modulus (sb-int:constant-form-value modulus env)))
    (declare (ntt-int modulus))
    `(progn
       (declaim (ntt-vector ,ntt-base ,ntt-inv-base))
       (sb-ext:define-load-time-global ,ntt-base
         (make-array ,base-size :element-type 'ntt-int))
       (sb-ext:define-load-time-global ,ntt-inv-base
         (make-array ,base-size :element-type 'ntt-int))
       (dotimes (i ,base-size)
         (setf (aref ,ntt-base i)
               (mod (- (%mod-power ,root (ash (- ,modulus 1) (- (+ i 2))) ,modulus))
                    ,modulus)
               (aref ,ntt-inv-base i)
               (%mod-inverse (aref ,ntt-base i) ,modulus)))

       (declaim (ftype (function * (values ntt-vector &optional)) ,ntt))
       (defun ,ntt (vector)
         (declare (optimize (speed 3) (safety 0))
                  (vector vector))
         (check-ntt-vector vector)
         (labels ((mod* (x y) (mod (* x y) ,modulus))
                  (mod+ (x y) (mod (+ x y) ,modulus))
                  (mod- (x y) (mod+ x (the ntt-int (- ,modulus y)))))
           (declare (inline mod* mod+ mod-))
           (let* ((vector (coerce vector 'ntt-vector))
                  (len (length vector))
                  (base ,ntt-base))
             (declare (ntt-vector vector base)
                      (ntt-int len))
             (when (<= len 1)
               (return-from ,ntt vector))
             (loop for m of-type ntt-int = (ash len -1) then (ash m -1)
                   while (> m 0)
                   for w of-type ntt-int = 1
                   for k of-type ntt-int = 0
                   do (loop for s of-type ntt-int from 0 below len by (* 2 m)
                            do (loop for i from s below (+ s m)
                                     for j from (+ s m)
                                     for x = (aref vector i)
                                     for y = (mod* (aref vector j) w)
                                     do (setf (aref vector i) (mod+ x y)
                                              (aref vector j) (mod- x y)))
                               (incf k)
                               (setq w (mod* w (aref base (%tzcount k))))))
             vector)))

       (declaim (ftype (function * (values ntt-vector &optional)) ,inverse-ntt))
       (defun ,inverse-ntt (vector &optional inverse)
         (declare (optimize (speed 3) (safety 0))
                  (vector vector))
         (check-ntt-vector vector)
         (labels ((mod* (x y) (mod (* x y) ,modulus))
                  (mod+ (x y) (mod (+ x y) ,modulus))
                  (mod- (x y) (mod+ x (the ntt-int (- ,modulus y)))))
           (declare (inline mod* mod+ mod-))
           (let* ((vector (coerce vector 'ntt-vector))
                  (len (length vector))
                  (base ,ntt-inv-base))
             (declare (ntt-vector vector base)
                      (ntt-int len))
             (when (<= len 1)
               (return-from ,inverse-ntt vector))
             (loop for m of-type ntt-int = 1 then (ash m 1)
                   while (< m len)
                   for w of-type ntt-int = 1
                   for k of-type ntt-int = 0
                   do (loop for s of-type ntt-int from 0 below len by (* 2 m)
                            do (loop for i from s below (+ s m)
                                     for j from (+ s m)
                                     for x = (aref vector i)
                                     for y = (aref vector j)
                                     do (setf (aref vector i) (mod+ x y)
                                              (aref vector j) (mod* (mod- x y) w)))
                               (incf k)
                               (setq w (mod* w (aref base (%tzcount k))))))
             (when inverse
               (let ((inv-len (mod-inverse len ,modulus)))
                 (dotimes (i len)
                   (setf (aref vector i) (mod* inv-len (aref vector i))))))
             vector)))

       (declaim (ftype (function * (values ntt-vector &optional)) ,convolve))
       (defun ,convolve (vector1 vector2)
         (declare (optimize (speed 3))
                  (vector vector1 vector2))
         ;; TODO: if (EQ VECTOR1 VECTOR2) holds, the number of FFTs can be
         ;; reduced.
         (let* ((len1 (length vector1))
                (len2 (length vector2))
                (mul-len (max 0 (- (+ len1 len2) 1)))
                (vector1 (coerce vector1 'ntt-vector))
                (vector2 (coerce vector2 'ntt-vector)))
           (declare (ntt-vector vector1 vector2)
                    ((mod #.array-dimension-limit) mul-len))
           (when (or (zerop len1) (zerop len2))
             (return-from ,convolve (make-array 0 :element-type 'ntt-int)))
           ;; naive convolution
           (when (<= (min len1 len2) 64)
             (let ((res (make-array mul-len :element-type 'ntt-int :initial-element 0)))
               (declare (optimize (speed 3) (safety 0)))
               (dotimes (d mul-len)
                 ;; 0 <= i <= deg1, 0 <= j <= deg2
                 (loop with coef of-type ntt-int = 0
                       for i from (max 0 (- d (- len2 1))) to (min d (- len1 1))
                       for j = (- d i)
                       do (setq coef (mod (+ coef (* (aref vector1 i) (aref vector2 j)))
                                          ,modulus))
                       finally (setf (aref res d) coef)))
               (return-from ,convolve res)))
           (let* (;; power of two ceiling
                  (required-len (ash 1 (integer-length (max 0 (- mul-len 1)))))
                  (vector1 (,ntt (%adjust-array vector1 required-len)))
                  (vector2 (,ntt (%adjust-array vector2 required-len))))
             (dotimes (i required-len)
               (setf (aref vector1 i)
                     (mod (* (aref vector1 i) (aref vector2 i)) ,modulus)))
             (subseq (,inverse-ntt vector1 t) 0 mul-len)))))))

#+(or)
(define-ntt +mod+)

