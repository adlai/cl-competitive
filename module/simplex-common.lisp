(defpackage :cp/simplex-common
  (:use :cl)
  (:export #:simplex-float #:+zero+ #:+eps+ #:+neg-inf+ #:+pos-inf+
           #:%restore #:%pivot))
(in-package :cp/simplex-common)

(deftype simplex-float () 'double-float)
(defconstant +zero+ (coerce 0 'simplex-float))
(defconstant +eps+ 1d-8)
(defconstant +neg-inf+ most-negative-double-float)
(defconstant +pos-inf+ most-positive-double-float)

;; dict: col(0), col(1), ...., col(n-1), row(0), row(1), ..., row(m-1)
;;      |---------- non-basic ---------| |---------- basic ----------|

(defun %restore (b c dict)
  (declare (optimize (speed 3))
           ((simple-array simplex-float (*)) b c)
           ((simple-array fixnum (*)) dict))
  (let* ((m (length b))
         (n (length c))
         (res-primal (make-array n :element-type 'simplex-float :initial-element +zero+))
         (res-dual (make-array m :element-type 'simplex-float :initial-element +zero+)))
    (dotimes (i m)
      (let ((index (aref dict (+ n i))))
        (when (< index n)
          (setf (aref res-primal index) (aref b i)))))
    (dotimes (j n)
      (let ((index (aref dict j)))
        (when (>= index n)
          (setf (aref res-dual (- index n)) (- (aref c j))))))
    (values res-primal res-dual)))

(declaim (ftype (function * (values simplex-float &optional)) %pivot))
(defun %pivot (row col a b c arow acol dict &optional b2 c2)
  (declare (optimize (speed 3))
           ((mod #.array-dimension-limit) row col)
           ((simple-array simplex-float (* *)) a)
           ((simple-array simplex-float (*)) b c arow acol)
           ((or null (simple-array simplex-float (*))) b2 c2)
           ((simple-array fixnum (*)) dict))
  (destructuring-bind (m n) (array-dimensions a)
    (declare ((mod #.array-dimension-limit) m n))
    (rotatef (aref dict col) (aref dict (+ n row)))
    (let* ((apivot (aref a row col))
           (/apivot (/ apivot)))
      (dotimes (i m)
        (dotimes (j n)
          (decf (aref a i j) (* (aref acol i) (aref arow j) /apivot))))
      (dotimes (j n)
        (setf (aref a row j) (* (aref arow j) /apivot)))
      (dotimes (i m)
        (setf (aref a i col) (- (* (aref acol i) /apivot))))
      (setf (aref a row col) /apivot)
      (let ((brow (aref b row)))
        (dotimes (i m)
          (decf (aref b i) (* brow (aref acol i) /apivot)))
        (setf (aref b row) (* brow /apivot))
        (when b2
          (let ((brow2 (aref b2 row)))
            (dotimes (i m)
              (decf (aref b2 i) (* brow2 (aref acol i) /apivot)))
            (setf (aref b row) (* brow /apivot)
                  (aref b2 row) (* brow2 /apivot))))
        (let ((ccol (aref c col)))
          (dotimes (j n)
            (decf (aref c j) (* ccol (aref arow j) /apivot)))
          (setf (aref c col) (- (* ccol /apivot)))
          (when c2
            (let ((ccol2 (aref c2 col)))
              (dotimes (j n)
                (decf (aref c2 j) (* ccol2 (aref arow j) /apivot)))
              (setf (aref c2 col) (- (* ccol2 /apivot)))))
          (* ccol brow /apivot))))))
