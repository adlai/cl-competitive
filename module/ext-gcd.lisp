(defpackage :cp/ext-gcd
  (:use :cl)
  (:export #:ext-gcd))
(in-package :cp/ext-gcd)

;; Blankinship algorithm
;; Reference: https://topcoder-g-hatena-ne-jp.jag-icpc.org/spaghetti_source/20130126/ (Japanese)
(declaim (ftype (function * (values fixnum fixnum &optional)) %ext-gcd))
(defun %ext-gcd (a b)
  (declare (optimize (speed 3) (safety 0))
           (fixnum a b))
  (let ((y 1)
        (x 0)
        (u 1)
        (v 0))
    (declare (fixnum y x u v))
    (loop (when (zerop a)
            (return (values x y)))
          (let ((q (floor b a)))
            (decf x (the fixnum (* q u)))
            (rotatef x u)
            (decf y (the fixnum (* q v)))
            (rotatef y v)
            (decf b (the fixnum (* q a)))
            (rotatef b a)))))

;; TODO: deal with bignums
(declaim (inline ext-gcd))
(defun ext-gcd (a b)
  "Returns two integers X and Y which satisfy AX + BY = gcd(A, B)."
  (declare ((integer #.(- most-positive-fixnum) #.most-positive-fixnum) a b))
  (if (>= a 0)
      (if (>= b 0)
          (%ext-gcd a b)
          (multiple-value-bind (x y) (%ext-gcd a (- b))
            (declare (fixnum x y))
            (values x (- y))))
      (if (>= b 0)
          (multiple-value-bind (x y) (%ext-gcd (- a) b)
            (declare (fixnum x y))
            (values (- x) y))
          (multiple-value-bind (x y) (%ext-gcd (- a) (- b))
            (declare (fixnum x y))
            (values (- x) (- y))))))
