(defpackage :cp/test/mod-convolve
  (:use :cl :fiveam :cp/mod-convolve :cp/mod-polynomial)
  (:import-from :cp/test/base #:base-suite)
  (:import-from :cp/mod-convolve #:uint))
(in-package :cp/test/mod-convolve)
(in-suite base-suite)

(defconstant +mod+ 1000000007)
(defconstant +mod2+ 998244353)

(test mod-convolve/hand
  (dolist (mod (list +mod+ +mod2+))
    (is (equalp #() (mod-convolve #() #() mod)))
    (is (equalp #(15) (mod-convolve #(3) #(5) mod)))
    (is (equalp (vector (- mod 45) 17 2 (- mod 5) 1)
                (mod-convolve (vector 5 (- mod 3) 1) (vector (- mod 9) (- mod 2) 1)
                              mod)))))

(defun make-random-polynomial (degree state modulus)
  (declare (optimize (speed 3))
           (uint modulus))
  (let ((res (make-array degree :element-type 'uint :initial-element 0)))
    (dotimes (i degree res)
      (setf (aref res i) (random modulus state)))
    (let ((end (+ 1 (or (position 0 res :from-end t :test-not #'eql) -1))))
      (subseq res 0 end))))

(test mod-convolve/random
  (let ((*test-dribble* nil)
        (state (sb-ext:seed-random-state 0)))
    (dolist (max-len '(10 128))
      (dotimes (_ 500)
        (let* ((len1 (random max-len state))
               (len2 (random max-len state))
               (poly1 (make-random-polynomial len1 state +mod+))
               (poly2 (make-random-polynomial len2 state +mod+)))
          (is (equalp (poly-mult poly1 poly2 +mod+)
                      (mod-convolve poly1 poly2 +mod+))))))
    (dolist (max-len '(10 128))
      (dotimes (_ 500)
        (let* ((len1 (random max-len state))
               (len2 (random max-len state))
               (poly1 (make-random-polynomial len1 state +mod2+))
               (poly2 (make-random-polynomial len2 state +mod2+)))
          (is (equalp (poly-mult poly1 poly2 +mod2+)
                      (mod-convolve poly1 poly2 +mod2+))))))))
