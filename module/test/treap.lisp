(eval-when (:compile-toplevel :load-toplevel :execute)
  (load "test-util")
  (load "../ref-able-treap.lisp"))

(use-package :test-util)

(defun copy-treap (treap)
  "For development. Recursively copies the whole TREAP."
  (declare ((or null treap) treap))
  (if (null treap)
      nil
      (%make-treap (%treap-key treap)
                   (%treap-priority treap)
                   :left (copy-treap (%treap-left treap))
                   :right (copy-treap (%treap-right treap))
                   :count (%treap-count treap))))

(defun treap-list (treap)
  (let (res)
    (labels ((recur (treap)
               (when treap
                 (recur (%treap-left treap))
                 (push (%treap-key treap) res)
                 (recur (%treap-right treap)))))
      (recur treap)
      (reverse res))))

(defun treap-priority (treap)
  (declare ((or null treap) treap))
  (if (null treap)
      0
      (%treap-priority treap)))

(defun treap-sane-p (treap)
  (or (null treap)
      (and (>= (%treap-priority treap)
               (treap-priority (%treap-left treap)))
           (>= (%treap-priority treap)
               (treap-priority (%treap-right treap)))
           (= (%treap-count treap)
              (+ 1
                 (treap-count (%treap-left treap))
                 (treap-count (%treap-right treap))))
           (treap-sane-p (%treap-left treap))
           (treap-sane-p (%treap-right treap)))))

(declaim (notinline make-treap treap-split treap-insert treap-delete treap-ref treap-find treap-position treap-bisect-left))

(with-test (:name treap-sanity)
  (dotimes (_ 10)
    (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10))))
    (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9))))
    (assert (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17))))
    (assert (treap-sane-p (make-treap #(1 2 3 4))))
    (assert (treap-sane-p (make-treap #(1))))
    (assert (treap-sane-p nil))))

(with-test (:name treap-fundamental)
  (multiple-value-bind (left right) (treap-split 5 (treap-insert 0 (treap-insert 10 (treap-insert 5 nil))))
    (assert (= 0 (%treap-key left)))
    (assert (null (%treap-left left)))
    (assert (null (%treap-right left)))
    (assert (or (typep (%treap-left right) 'treap)
                (typep (%treap-right right) 'treap))))

  (let ((treap1 (%make-treap 50 15 :count 5))
        (treap2 (%make-treap 100 11 :count 3)))
    (setf (%treap-left treap1) (%make-treap 30 5 :count 3))
    (setf (%treap-left (%treap-left treap1)) (%make-treap 20 2 :count 1))
    (setf (%treap-right (%treap-left treap1)) (%make-treap 40 4 :count 1))
    (setf (%treap-right treap1) (%make-treap 70 10 :count 1))
    (setf (%treap-right treap2) (%make-treap 200 3 :count 1))
    (setf (%treap-left treap2) (%make-treap 99 5 :count 1))
    ;; copy-treap
    (assert (equalp treap1 (copy-treap treap1)))
    (assert (not (eql treap1 (copy-treap treap1))))
    ;; split and merge
    (let ((treap (treap-merge (copy-treap treap1) (copy-treap treap2))))
      (assert (= 8 (%treap-count treap)))
      (multiple-value-bind (left right) (treap-split 80 (copy-treap treap))
        (assert (= 5 (%treap-count left)))
        (assert (= 3 (%treap-count right)))
        (assert (equalp treap (treap-merge left right)))))
    ;; find
    (assert (= 40 (treap-find 40 treap1)))
    (assert (null (treap-find 41 treap1)))
    ;; insert and delete
    (let ((inserted-treap1 (treap-insert 41 (copy-treap treap1))))
      (assert (= 41 (treap-find 41 inserted-treap1)))
      (let ((deleted-treap1 (treap-delete 41 inserted-treap1)))
        (assert (null (treap-find 41 deleted-treap1)))
        (assert (equalp treap1 deleted-treap1))
        (assert (equalp treap1 (treap-delete 41 deleted-treap1)))))
    (let ((treap (treap-merge treap1 treap2)))
      (assert (= 20 (treap-ref treap 0)))
      (assert (= 30 (treap-ref treap 1)))
      (assert (= 40 (treap-ref treap 2)))
      (assert (= 50 (treap-ref treap 3)))
      (assert (= 70 (treap-ref treap 4)))
      (assert (= 99 (treap-ref treap 5)))
      (assert (= 100 (treap-ref treap 6)))
      (assert (= 200 (treap-ref treap 7)))
      (assert (= 20 (treap-first treap)))
      (assert (= 200 (treap-last treap))))))

(with-test (:name treap-ref)
  (let ((treap (make-treap #(1 2 3 5 7))))
    (assert (= 7 (treap-ref treap 4)))
    (assert (= 1 (treap-ref treap 0)))
    (assert (= 1 (treap-first treap)))
    (assert (= 7 (treap-last treap)))))

(with-test (:name treap-unite)
  (let ((treap (treap-unite (treap #'> 10 8 3 2 1)
                            (treap #'> 10 8 4 -1)
                            :order #'>)))
    (assert (equalp '(10 10 8 8 4 3 2 1 -1) (treap-list treap)))
    (assert (= 10 (treap-ref treap 0)))
    (assert (= 10 (treap-ref treap 1)))
    (assert (= 8 (treap-ref treap 2)))
    (assert (= 8 (treap-ref treap 3)))
    (assert (= 4 (treap-ref treap 4)))
    (assert (= 3 (treap-ref treap 5)))
    (assert (= 2 (treap-ref treap 6)))
    (assert (= 1 (treap-ref treap 7)))
    (assert (= -1 (treap-ref treap 8))))
  (assert (equalp '(1 2 3 8 10)
                  (treap-list (treap-unite (treap #'< 1 2 3 8 10) nil))))
  (assert (equalp '(1 2 3 3 10)
                  (treap-list (treap-unite nil (treap #'< 1 2 3 3 10)))))
  (assert (null (treap-unite nil nil :order #'string<))))

(with-test (:name treap-reverse)
  (equalp '(1 2 3 3 4 5 10)
          (treap-list (treap-reverse (treap #'> 10 5 4 3 3 2 )))))

(with-test (:name treap-bisect)
  (let ((treap (treap #'< 1 2 3 5 6 10)))
    (assert (= 0 (treap-position 1 treap)))
    (assert (= 1 (treap-position 2 treap)))
    (assert (= 2 (treap-position 3 treap)))
    (assert (null (treap-position 4 treap)))
    (assert (= 3 (treap-position 5 treap)))
    (assert (= 4 (treap-position 6 treap)))
    (assert (null (treap-position 7 treap)))
    (assert (= 5 (treap-position 10 treap)))
    (assert (null (treap-position 11 treap)))

    (assert (= 1 (treap-find 1 treap)))
    (assert (= 2 (treap-find 2 treap)))
    (assert (= 3 (treap-find 3 treap)))
    (assert (null (treap-find 4 treap)))
    (assert (= 5 (treap-find 5 treap)))
    (assert (= 6 (treap-find 6 treap)))
    (assert (null (treap-find 7 treap)))
    (assert (= 10 (treap-find 10 treap)))
    (assert (null (treap-find 11 treap)))

    (assert (= 0 (treap-bisect-left 0 treap)))
    (assert (= 0 (treap-bisect-left 1 treap)))
    (assert (= 1 (treap-bisect-left 2 treap)))
    (assert (= 2 (treap-bisect-left 3 treap)))
    (assert (= 3 (treap-bisect-left 4 treap)))
    (assert (= 3 (treap-bisect-left 5 treap)))
    (assert (= 4 (treap-bisect-left 6 treap)))
    (assert (= 5 (treap-bisect-left 7 treap)))
    (assert (= 5 (treap-bisect-left 10 treap)))
    (assert (= 6 (treap-bisect-left 11 treap)))))
