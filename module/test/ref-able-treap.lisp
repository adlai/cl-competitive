(defpackage :cp/test/ref-able-treap
  (:use :cl :fiveam :cp/ref-able-treap)
  (:import-from :cp/test/base #:base-suite)
  (:import-from :cp/ref-able-treap
                #:%make-treap
                #:%treap-key #:%treap-priority #:%treap-left #:%treap-right #:%treap-count))
(in-package :cp/test/ref-able-treap)
(in-suite base-suite)

(defun copy-treap (treap)
  "For development. Recursively copies the whole TREAP."
  (declare ((or null treap) treap))
  (if (null treap)
      nil
      (%make-treap (%treap-key treap)
                   (%treap-priority treap)
                   :left (copy-treap (%treap-left treap))
                   :right (copy-treap (%treap-right treap))
                   :count (%treap-count treap))))

(defun treap-list (treap)
  (let (res)
    (labels ((recur (treap)
               (when treap
                 (recur (%treap-left treap))
                 (push (%treap-key treap) res)
                 (recur (%treap-right treap)))))
      (recur treap)
      (reverse res))))

(defun treap-priority (treap)
  (declare ((or null treap) treap))
  (if (null treap)
      0
      (%treap-priority treap)))

(defun treap-sane-p (treap)
  (or (null treap)
      (and (>= (%treap-priority treap)
               (treap-priority (%treap-left treap)))
           (>= (%treap-priority treap)
               (treap-priority (%treap-right treap)))
           (= (%treap-count treap)
              (+ 1
                 (treap-count (%treap-left treap))
                 (treap-count (%treap-right treap))))
           (treap-sane-p (%treap-left treap))
           (treap-sane-p (%treap-right treap)))))

(test treap-sanity
  (declare (notinline make-treap))
  (dotimes (_ 10)
    (is (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10))))
    (is (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9))))
    (is (treap-sane-p (make-treap #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17))))
    (is (treap-sane-p (make-treap #(1 2 3 4))))
    (is (treap-sane-p (make-treap #(1))))
    (is (treap-sane-p nil))))

(test treap-fundamental
  (declare (notinline treap-split treap-insert treap-delete treap-ref treap-find treap-position treap-bisect-left))
  (multiple-value-bind (left right) (treap-split 5 (treap-insert 0 (treap-insert 10 (treap-insert 5 nil))))
    (is (= 0 (%treap-key left)))
    (is (null (%treap-left left)))
    (is (null (%treap-right left)))
    (is (or (typep (%treap-left right) 'treap)
                (typep (%treap-right right) 'treap))))

  (let ((treap1 (%make-treap 50 15 :count 5))
        (treap2 (%make-treap 100 11 :count 3)))
    (setf (%treap-left treap1) (%make-treap 30 5 :count 3))
    (setf (%treap-left (%treap-left treap1)) (%make-treap 20 2 :count 1))
    (setf (%treap-right (%treap-left treap1)) (%make-treap 40 4 :count 1))
    (setf (%treap-right treap1) (%make-treap 70 10 :count 1))
    (setf (%treap-right treap2) (%make-treap 200 3 :count 1))
    (setf (%treap-left treap2) (%make-treap 99 5 :count 1))
    ;; copy-treap
    (is (equalp treap1 (copy-treap treap1)))
    (is (not (eql treap1 (copy-treap treap1))))
    ;; split and merge
    (let ((treap (treap-merge (copy-treap treap1) (copy-treap treap2))))
      (is (= 8 (%treap-count treap)))
      (multiple-value-bind (left right) (treap-split 80 (copy-treap treap))
        (is (= 5 (%treap-count left)))
        (is (= 3 (%treap-count right)))
        (is (equalp treap (treap-merge left right)))))
    ;; find
    (is (= 40 (treap-find 40 treap1)))
    (is (null (treap-find 41 treap1)))
    ;; insert and delete
    (let ((inserted-treap1 (treap-insert 41 (copy-treap treap1))))
      (is (= 41 (treap-find 41 inserted-treap1)))
      (let ((deleted-treap1 (treap-delete 41 inserted-treap1)))
        (is (null (treap-find 41 deleted-treap1)))
        (is (equalp treap1 deleted-treap1))
        (is (equalp treap1 (treap-delete 41 deleted-treap1)))))
    (let ((treap (treap-merge treap1 treap2)))
      (is (= 20 (treap-ref treap 0)))
      (is (= 30 (treap-ref treap 1)))
      (is (= 40 (treap-ref treap 2)))
      (is (= 50 (treap-ref treap 3)))
      (is (= 70 (treap-ref treap 4)))
      (is (= 99 (treap-ref treap 5)))
      (is (= 100 (treap-ref treap 6)))
      (is (= 200 (treap-ref treap 7)))
      (is (= 20 (treap-first treap)))
      (is (= 200 (treap-last treap))))))

(test treap-ref
  (let ((treap (make-treap #(1 2 3 5 7))))
    (is (= 7 (treap-ref treap 4)))
    (is (= 1 (treap-ref treap 0)))
    (is (= 1 (treap-first treap)))
    (is (= 7 (treap-last treap)))))

(test treap-unite
  (declare (notinline treap treap-ref treap-unite))
  (let ((treap (treap-unite (treap #'> 10 8 3 2 1)
                            (treap #'> 10 8 4 -1)
                            :order #'>)))
    (is (equalp '(10 10 8 8 4 3 2 1 -1) (treap-list treap)))
    (is (= 10 (treap-ref treap 0)))
    (is (= 10 (treap-ref treap 1)))
    (is (= 8 (treap-ref treap 2)))
    (is (= 8 (treap-ref treap 3)))
    (is (= 4 (treap-ref treap 4)))
    (is (= 3 (treap-ref treap 5)))
    (is (= 2 (treap-ref treap 6)))
    (is (= 1 (treap-ref treap 7)))
    (is (= -1 (treap-ref treap 8))))
  (is (equalp '(1 2 3 8 10)
                  (treap-list (treap-unite (treap #'< 1 2 3 8 10) nil))))
  (is (equalp '(1 2 3 3 10)
                  (treap-list (treap-unite nil (treap #'< 1 2 3 3 10)))))
  (is (null (treap-unite nil nil :order #'string<))))

(test treap-reverse
  (is (equalp '(1 2 3 3 4 5 10)
              (treap-list (treap-reverse (treap #'> 10 5 4 3 3 2 1))))))

(test treap-bisect
  (declare (notinline treap-position treap-find treap-bisect-left treap-bisect-right))
  (let ((treap (treap #'< 1 2 3 5 6 10)))
    (is (= 0 (treap-position 1 treap)))
    (is (= 1 (treap-position 2 treap)))
    (is (= 2 (treap-position 3 treap)))
    (is (null (treap-position 4 treap)))
    (is (= 3 (treap-position 5 treap)))
    (is (= 4 (treap-position 6 treap)))
    (is (null (treap-position 7 treap)))
    (is (= 5 (treap-position 10 treap)))
    (is (null (treap-position 11 treap)))

    (is (= 1 (treap-find 1 treap)))
    (is (= 2 (treap-find 2 treap)))
    (is (= 3 (treap-find 3 treap)))
    (is (null (treap-find 4 treap)))
    (is (= 5 (treap-find 5 treap)))
    (is (= 6 (treap-find 6 treap)))
    (is (null (treap-find 7 treap)))
    (is (= 10 (treap-find 10 treap)))
    (is (null (treap-find 11 treap)))

    (is (= 0 (treap-bisect-left 0 treap)))
    (is (= 0 (treap-bisect-left 1 treap)))
    (is (= 1 (treap-bisect-left 2 treap)))
    (is (= 2 (treap-bisect-left 3 treap)))
    (is (= 3 (treap-bisect-left 4 treap)))
    (is (= 3 (treap-bisect-left 5 treap)))
    (is (= 4 (treap-bisect-left 6 treap)))
    (is (= 5 (treap-bisect-left 7 treap)))
    (is (= 5 (treap-bisect-left 10 treap)))
    (is (= 6 (treap-bisect-left 11 treap)))

    (is (= 0 (treap-bisect-right 0 treap)))
    (is (= 1 (treap-bisect-right 1 treap)))
    (is (= 2 (treap-bisect-right 2 treap)))
    (is (= 3 (treap-bisect-right 3 treap)))
    (is (= 3 (treap-bisect-right 4 treap)))
    (is (= 4 (treap-bisect-right 5 treap)))
    (is (= 5 (treap-bisect-right 6 treap)))
    (is (= 5 (treap-bisect-right 7 treap)))
    (is (= 5 (treap-bisect-right 9 treap)))
    (is (= 6 (treap-bisect-right 10 treap)))))

(test treap/push-pop
  (let ((vector (vector nil nil)))
    (is (null (treap-find 10 (aref vector 1))))
    (is (zerop (treap-bisect-left 15 (aref vector 1))))
    (treap-push 10 (aref vector 1))
    (treap-push 20 (aref vector 1))
    (is (null (aref vector 0)))
    (is (= 10 (treap-find 10 (aref vector 1))))
    (is (= 1 (treap-bisect-left 15 (aref vector 1))))
    (treap-pop 10 (aref vector 1))))
