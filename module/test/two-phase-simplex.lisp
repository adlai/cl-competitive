(defpackage :cp/test/two-phase-simplex
  (:use :cl :fiveam :cp/two-phase-simplex :cp/test/nearly-equal :cp/gaussian)
  (:import-from :cp/test/base #:base-suite)
  (:import-from :cp/two-phase-simplex #:%primal-simplex! #:%dual-simplex!))
(in-package :cp/test/two-phase-simplex)
(in-suite base-suite)

(declaim (ftype (function * (values (simple-array double-float (* *))
                                    (simple-array double-float (*))
                                    (simple-array double-float (*))
                                    &optional))
                dual-std))
(defun dual-std (a b c)
  (destructuring-bind (m n) (array-dimensions a)
    (let ((a* (make-array (list n m) :element-type 'double-float :initial-element 0d0))
          (b* (map '(simple-array double-float (*)) #'- c))
          (c* (map '(simple-array double-float (*)) #'- b)))
      (dotimes (i m)
        (dotimes (j n)
          (setf (aref a* j i) (- (aref a i j)))))
      (values a* b* c*))))

(defun copy (a)
  (let ((res (make-array (array-dimensions a) :element-type 'double-float)))
    (replace (sb-ext:array-storage-vector res) (sb-ext:array-storage-vector a))
    res))

(defun check (a b c obj)
  (multiple-value-bind (a* b* c*) (dual-std a b c)
    (multiple-value-bind (obj1 prim1 dual1) (%primal-simplex! (copy a) (copy b) (copy c))
      (multiple-value-bind (obj2 prim2 dual2) (%dual-simplex! (copy a*) (copy b*) (copy c*))
        (is (nearly= 1d-8 obj obj1 (- obj2)))
        (is (nearly-equal 1d-8 (coerce prim1 'list) (coerce dual2 'list)))
        (is (nearly-equal 1d-8 (coerce dual1 'list) (coerce prim2 'list)))))))

(defconstant +eps+ 1d-8)

(defun check* (a b c)
  (declare (optimize (speed 3))
           ((simple-array double-float (* *)) a)
           ((simple-array double-float (*)) b c))
  (destructuring-bind (m n) (array-dimensions a)
    (declare ((mod #.array-dimension-limit) m n))
    (multiple-value-bind (result prim dual) (dual-primal! (copy a) (copy b) (copy c))
      (multiple-value-bind (a* b* c*) (dual-std a b c)
        (cond ((eql result :infeasible)
               (let ((result2 (dual-primal! a* b* c*)))
                 (is (eql result2 :unbounded))))
              ((eql result :unbounded)
               (let ((result2 (dual-primal! a* b* c*)))
                 (is (eql result2 :infeasible))))
              (t
               (dotimes (i m)
                 (let ((lhs 0d0))
                   (declare (double-float lhs))
                   (dotimes (j n)
                     (incf lhs (* (aref a i j) (aref prim j))))
                   (is (<= lhs (+ +eps+ (aref b i))))))
               (dotimes (i n)
                 (let ((lhs 0d0))
                   (declare (double-float lhs))
                   (dotimes (j m)
                     (incf lhs (* (aref a* i j) (aref dual j))))
                   (is (<= lhs (+ +eps+ (aref b* i))))))
               (let ((obj1 0d0)
                     (obj2 0d0))
                 (declare (double-float obj1 obj2))
                 (dotimes (j n)
                   (incf obj1 (* (aref c j) (aref prim j))))
                 (dotimes (j m)
                   (incf obj2 (* (aref c* j) (aref dual j))))
                 (is (nearly= 1d-8 result obj1 (- obj2))))))))))

(defun make-random-instance (sigma feasible-p)
  (declare (optimize (speed 3))
           (double-float sigma))
  (let* ((m (round (* 5 (exp (* #.(log 10d0) (random 1d0))))))
         (n (round (* 5 (exp (* #.(log 10d0) (random 1d0))))))
         (as (make-array (list m n) :element-type 'double-float :initial-element 0d0))
         (bs (make-array m :element-type 'double-float :initial-element 0d0))
         (cs (make-array n :element-type 'double-float :initial-element 0d0)))
    (dotimes (i m)
      (dotimes (j n)
        (setf (aref as i j) (* sigma (gaussian)))))
    (dotimes (i m)
      (setf (aref bs i) (* sigma (gaussian))))
    (when feasible-p
      (dotimes (i m)
        (setf (aref bs i) (abs (aref bs i)))))
    (dotimes (j n)
      (setf (aref cs j) (* sigma (gaussian))))
    (values as bs cs)))

(test two-phase-simplex/hand
  (let ((a #2a((2d0 1d0 1d0 3d0) (1d0 3d0 1d0 2d0)))
        (b #(5d0 3d0))
        (c #(6d0 8d0 5d0 9d0)))
    (check a b c 17d0))
  (let ((a #2a((2d0 1d0) (2d0 3d0) (4d0 1d0) (1d0 5d0)))
        (b #(4d0 3d0 5d0 1d0))
        (c #(2d0 1d0)))
    (check a b c 2d0)))

(test two-phase-simplex/random
  (let ((*test-dribble* nil)
        (*random-state* (sb-ext:seed-random-state 0)))
    (dotimes (_ 500)
      (multiple-value-bind (a b c) (make-random-instance 10d0 t)
        (check* a b c)))
    (dotimes (_ 500)
      (multiple-value-bind (a b c) (make-random-instance 10d0 nil)
        (check* a b c)))))
