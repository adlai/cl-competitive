(defpackage :cp/test/cumulative-sum
  (:use :cl :fiveam :cp/cumulative-sum)
  (:import-from :cp/test/base #:base-suite))
(in-package :cp/test/cumulative-sum)
(in-suite base-suite)

(defun %2d-get (cumul-table i0 j0 i1 j1)
  (+ (- (aref cumul-table i1 j1)
        (aref cumul-table i0 j1)
        (aref cumul-table i1 j0))
     (aref cumul-table i0 j0)))

(defun %2d-build! (cumul-table)
  (destructuring-bind (h+1 w+1) (array-dimensions cumul-table)
    (declare ((integer 0 #.most-positive-fixnum) h+1 w+1))
    (let ((h (- h+1 1))
          (w (- w+1 1)))
      (declare ((integer 0 #.most-positive-fixnum) h w))
      (dotimes (i h+1)
        (dotimes (j w)
          (incf (aref cumul-table i (+ j 1))
                (aref cumul-table i j))))
      (dotimes (j w+1)
        (dotimes (i h)
          (incf (aref cumul-table (+ i 1) j)
                (aref cumul-table i j))))))
  cumul-table)

(test cumulative-sum/2d
  (let ((state (sb-ext:seed-random-state 0)))
    (finishes
      (dotimes (_ 100)
        (let* ((h (+ 1 (random 10 state)))
               (w (+ 1 (random 10 state)))
               (table1 (make-array (list (+ h 1) (+ w 1)) :element-type 'fixnum))
               (table2 (make-array (list (+ h 1) (+ w 1)) :element-type 'fixnum)))
          (dotimes (i h)
            (dotimes (j w)
              (let ((value (random #xffffffff state)))
                (setf (aref table1 (+ i 1) (+ j 1)) value
                      (aref table2 (+ i 1) (+ j 1)) value))))
          (%2d-build! table1)
          (2dcumul-build! table2)
          (dotimes (_ 100)
            (let ((i0 (random (+ h 1) state))
                  (i1 (random (+ h 1) state))
                  (j0 (random (+ w 1) state))
                  (j1 (random (+ w 1) state)))
              (when (> i0 i1) (rotatef i0 i1))
              (when (> j0 j1) (rotatef j0 j1))
              (assert (= (%2d-get table1 i0 j0 i1 j1)
                         (2dcumul-get table2 i0 j0 i1 j1))))))))))

(defun %4d-get (array lo0 lo1 lo2 lo3 hi0 hi1 hi2 hi3)
  (let ((value 0))
    (loop for u from lo0 below hi0
          do (loop for v from lo1 below hi1
                   do (loop for w from lo2 below hi2
                            do (loop for x from lo3 below hi3
                                     do (incf value (aref array u v w x))))))
    value))

(define-cumulative-sum 4d 4)

(test cumulative-sum/4d
  (let ((state (sb-ext:seed-random-state 0)))
    (finishes
      (dotimes (_ 100)
        (let* ((w1 (+ 1 (random 8 state)))
               (w2 (+ 1 (random 8 state)))
               (w3 (+ 1 (random 8 state)))
               (w4 (+ 1 (random 8 state)))
               (array (make-array (list w1 w2 w3 w4) :element-type 'fixnum))
               (cumul (make-array (list (+ w1 1) (+ w2 1) (+ w3 1) (+ w4 1))
                                  :element-type 'fixnum)))
          (dotimes (i1 w1)
            (dotimes (i2 w2)
              (dotimes (i3 w3)
                (dotimes (i4 w4)
                  (let ((value (random #xffffffff state)))
                    (setf (aref array i1 i2 i3 i4) value
                          (aref cumul (+ i1 1) (+ i2 1) (+ i3 1) (+ i4 1)) value))))))
          (4d-build! cumul)
          (dotimes (_ 100)
            (let ((lo1 (random (+ w1 1) state))
                  (lo2 (random (+ w2 1) state))
                  (lo3 (random (+ w3 1) state))
                  (lo4 (random (+ w4 1) state))
                  (hi1 (random (+ w1 1) state))
                  (hi2 (random (+ w2 1) state))
                  (hi3 (random (+ w3 1) state))
                  (hi4 (random (+ w4 1) state)))
              (when (> lo1 hi1) (rotatef lo1 hi1))
              (when (> lo2 hi2) (rotatef lo2 hi2))
              (when (> lo3 hi3) (rotatef lo3 hi3))
              (when (> lo4 hi4) (rotatef lo4 hi4))
              (assert (= (%4d-get array lo1 lo2 lo3 lo4 hi1 hi2 hi3 hi4)
                         (4d-get cumul lo1 lo2 lo3 lo4 hi1 hi2 hi3 hi4))))))))))
