(defpackage :cp/test/explicit-treap
  (:use :cl :fiveam :cp/explicit-treap)
  (:import-from :cp/test/base #:base-suite)
  (:import-from :cp/explicit-treap
                #:%treap-priority #:%treap-key #:%treap-left #:%treap-right
                #:%treap-accumulator #:%treap-value #:%make-treap #:op))
(in-package :cp/test/explicit-treap)
(in-suite base-suite)

(defun treap-priority (treap)
  (declare ((or null treap) treap))
  (if (null treap)
      0
      (%treap-priority treap)))

(defun treap-sane-p (treap)
  (or (null treap)
      (and (>= (%treap-priority treap)
               (treap-priority (%treap-left treap)))
           (>= (%treap-priority treap)
               (treap-priority (%treap-right treap)))
           (= (%treap-accumulator treap)
              (op (op (treap-accumulator (%treap-left treap))
                      (%treap-value treap))
                  (treap-accumulator (%treap-right treap))))
           (treap-sane-p (%treap-left treap))
           (treap-sane-p (%treap-right treap)))))

(defun copy-treap (treap)
  "For development. Recursively copies the whole TREAP."
  (declare ((or null treap) treap))
  (if (null treap)
      nil
      (%make-treap (%treap-key treap)
                   (%treap-priority treap)
                   (%treap-value treap)
                   :accumulator (%treap-accumulator treap)
                   :left (copy-treap (%treap-left treap))
                   :right (copy-treap (%treap-right treap)))))

(test explicit-treap-sanity
  (declare (notinline make-treap))
  (labels ((to-func (vector) (lambda (i) (aref vector i))))
    (dotimes (_ 10)
      (is (treap-sane-p (make-treap 10 (to-func #(1 2 3 4 5 6 7 8 9 10)) (to-func #(3 3 3 6 9 8 9 11 0 1)))))
      (is (treap-sane-p (make-treap 9 (to-func #(1 2 3 4 5 6 7 8 9)))))
      (is (treap-sane-p (make-treap 17 (to-func #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17)))))
      (is (treap-sane-p (make-treap 4 (to-func #(1 2 3 4)) (to-func #(-1 -2 -3 4)))))
      (is (treap-sane-p (make-treap 1 (to-func #(1)))))
      (is (treap-sane-p nil)))))

(test explicit-treap/hand
  (let (treap)
    (setq treap (treap-insert treap 3 6 :order #'>))
    (setq treap (treap-insert treap 1 0 :order #'>))
    (is (= 0 (treap-ref treap 1 :order #'>)))
    (is (null (treap-ref treap 10 :order #'>)))
    (is (= 3 (treap-ref treap 10 :order #'> :default 3)))
    (setf (treap-ref treap 1 :order #'>) 2)
    (setq treap (%treap-ensure-key treap 2 4 :order #'>))
    (is (= 2 (treap-ref treap 1 :order #'>)))
    (is (= 4 (treap-ref treap 2 :order #'>)))
    (is (= 6 (treap-ref treap 3 :order #'>)))
    (setf (treap-ref treap 4 :order #'>) 8)
    (is (= 8 (treap-ref treap 4 :order #'>)))
    (incf (treap-ref treap 0 :order #'> :default 100) 100)
    (is (= 200 (treap-ref treap 0 :order #'>)))
    (treap-pop treap 5 #'>)
    (treap-pop treap 0 #'>)
    (is (null (treap-ref treap 0 :order #'>)))))

(test explicit-treap-bisection
  (declare (notinline treap-bisect-left treap-bisect-right treap-bisect-left-1 treap-bisect-right-1))
  (let ((treap (treap #'> '(50 . 3) '(20 . 1) '(40 . 4))))
    (is (null (treap-find treap 0 :order #'>)))
    (is (= 50 (treap-find treap 50 :order #'>)))
    (is (= 40 (treap-find treap 40 :order #'>)))
    (is (= 20 (treap-find treap 20 :order #'>)))
    (is (null (treap-bisect-right-1 treap 51 :order #'>)))
    (is (= 50 (treap-bisect-right-1 treap 50 :order #'>)))
    (is (= 50 (treap-bisect-right-1 treap 49 :order #'>)))
    (is (= 40 (treap-bisect-right-1 treap 40 :order #'>)))
    (is (= 20 (treap-bisect-right-1 treap 0 :order #'>)))
    (is (= 50 (treap-bisect-left treap 51 :order #'>)))
    (is (= 50 (treap-bisect-left treap 50 :order #'>)))
    (is (= 40 (treap-bisect-left treap 49 :order #'>)))
    (is (= 40 (treap-bisect-left treap 40 :order #'>)))
    (is (null (treap-bisect-left treap 0 :order #'>)))
    (is (= 50 (treap-bisect-right treap 51 :order #'>)))
    (is (= 40 (treap-bisect-right treap 50 :order #'>)))
    (is (= 20 (treap-bisect-right treap 40 :order #'>)))
    (is (null (treap-bisect-right treap 20 :order #'>)))
    (is (null (treap-bisect-left-1 treap 50 :order #'>)))
    (is (= 50 (treap-bisect-left-1 treap 49 :order #'>)))
    (is (= 50 (treap-bisect-left-1 treap 40 :order #'>)))
    (is (= 40 (treap-bisect-left-1 treap 39 :order #'>)))
    (is (= 20 (treap-bisect-left-1 treap 19 :order #'>)))
    (is (= 20 (treap-bisect-left-1 treap -10000 :order #'>)))))
