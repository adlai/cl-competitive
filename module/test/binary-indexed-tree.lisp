(defpackage :cp/test/binary-indexed-tree
  (:use :cl :fiveam :cp/binary-indexed-tree)
  (:import-from :cp/test/base #:base-suite))
(in-package :cp/test/binary-indexed-tree)
(in-suite base-suite)

(define-bitree bitree
  :operator #'+
  :identity 0
  :sum-type fixnum
  :order #'<)

(test binary-indexed-tree/random
  (let ((*test-dribble* nil)
        (*random-state* (sb-ext:seed-random-state 0)))
    (loop for size from 1 to 30
          for dp = (make-array size :element-type 'fixnum :initial-element 0)
          do (dotimes (i size)
               (setf (aref dp i) (random 8)))
             (let ((bitree (copy-seq dp)))
               (bitree-build! bitree)
               (dotimes (_ 200)
                 (ecase (random 4)
                   (0 (let ((index (random size))
                            (delta (random 8)))
                        (bitree-update! bitree index delta)
                        (incf (aref dp index) delta)))
                   (1 (let ((end (random (+ 1 size)))
                            (sum 0))
                        (dotimes (i end)
                          (incf sum (aref dp i)))
                        (is (= sum (bitree-fold bitree end)))))
                   (2 (let ((end 0)
                            (sum 0)
                            (threshold (random (+ 1 (* 2 (reduce #'+ dp))))))
                        (loop (when (= end size)
                                (return))
                              (incf sum (aref dp end))
                              (when (>= sum threshold)
                                (return))
                              (incf end))
                        (is (= end (bitree-bisect-left bitree threshold)))))
                   (3 (let ((end 0)
                            (sum 0)
                            (threshold (random (+ 1 (* 2 (reduce #'+ dp))))))
                        (loop (when (= end size)
                                (return))
                              (incf sum (aref dp end))
                              (when (> sum threshold)
                                (return))
                              (incf end))
                        (is (= end (bitree-bisect-right bitree threshold)))))))))))

(test binary-indexed-tree/hand
  (declare (notinline bitree-fold bitree-bisect-left bitree-bisect-right bitree-build!))
  (let ((tree (bitree-build! (vector 10 2 0 0 1 2 2)))
        (tree2 (bitree-build! (vector 1 0 0 1))))
    (is (= 0 (bitree-bisect-left tree -1)))
    (is (= 0 (bitree-bisect-left tree 0)))
    (is (= 0 (bitree-bisect-left tree 3)))
    (is (= 0 (bitree-bisect-left tree 10)))
    (is (= 1 (bitree-bisect-left tree 11)))
    (is (= 1 (bitree-bisect-left tree 12)))
    (is (= 4 (bitree-bisect-left tree 13)))
    (is (= 5 (bitree-bisect-left tree 14)))
    (is (= 6 (bitree-bisect-left tree 17)))
    (is (= 7 (bitree-bisect-left tree 18)))
    (is (= 7 (bitree-bisect-left tree 200)))
    (is (= 0 (bitree-bisect-left tree2 0)))
    (is (= 0 (bitree-bisect-left tree2 1)))
    (is (= 3 (bitree-bisect-left tree2 2)))
    (is (= 1 (bitree-fold tree2 3)))
    (is (= 2 (bitree-fold tree2 4)))
    (is (= 4 (bitree-bisect-left tree2 30000)))
    (is (= 0 (bitree-bisect-right tree2 -1)))
    (is (= 0 (bitree-bisect-right tree2 0)))
    (is (= 3 (bitree-bisect-right tree2 1)))
    (is (= 4 (bitree-bisect-right tree2 2)))
    (is (= 4 (bitree-bisect-right tree2 30000)))))
