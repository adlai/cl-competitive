(defpackage :cp/test/sparse-simplex
  (:use :cl :fiveam :cp/sparse-simplex :cp/test/nearly-equal
        :cp/csc :cp/lud :cp/lp-test-tool :cp/shuffle)
  (:import-from :cp/test/base #:base-suite)
  (:import-from :cp/sparse-simplex #:tmat-times-vec!))
(in-package :cp/test/sparse-simplex)
(in-suite base-suite)

(test tmat-times-vec!
  (let* ((vec (make-sparse-vector-from #(1d0 0d0 2d0 0d0 -1d0)))
         (tmat (make-csc-from-array #2a((1d0 2d0 3d0 4d0 7d0)
                                        (6d0 7d0 8d0 9d0 10d0)
                                        (11d0 12d0 13d0 14d0 15d0)
                                        (16d0 17d0 18d0 19d00 20d0)
                                        (21d0 22d0 23d0 24d0 25d0)
                                        (100d0 0d0 100d0 1d0 1d0))))
         (res (make-sparse-vector 5))
         (basic-flag (coerce '(-1 -2 -4 -5 0 -3) '(simple-array fixnum (*))))
         (dense (make-array-from-sparse-vector
                 (tmat-times-vec! tmat vec basic-flag nil res))))
    (is (nearly-equalp 1d-8 #(0d0 12d0 299d0 22d0 32d0) dense)))
  (is (equalp #()
              (make-array-from-sparse-vector
               (tmat-times-vec! (make-csc-from-array #2a())
                                (make-sparse-vector 0)
                                (make-array 0 :element-type 'fixnum)
                                nil
                                (make-sparse-vector 0))))))

(test slp-primal!
  ;; trival lp
  (let* ((b (make-array 0 :element-type 'double-float))
         (c (make-array 0 :element-type 'double-float))
         (lp (make-sparse-lp (make-csc-from-array #2a()) b c)))
    (is (eql :optimal (slp-primal! lp)))
    (multiple-value-bind (obj prim dual) (slp-restore lp)
      (is (zerop obj))
      (is (equalp #() prim))
      (is (equalp #() dual))))
  ;; zero lp
  (dolist (dim '((2 . 3) (10 . 10) (1 . 1) (10 . 3) (3 . 10)))
    (destructuring-bind (m . n) dim
      (let* ((mat (make-array (list m n) :element-type 'double-float :initial-element 0d0))
             (b (make-array m :element-type 'double-float :initial-element 0d0))
             (c+ (make-array n :element-type 'double-float :initial-element 1d0))
             (c- (make-array n :element-type 'double-float :initial-element -1d0)))
        (dotimes (i m)
          (setf (aref b i) (float (random 20) 1d0)))
        (let* ((lp (make-sparse-lp (make-csc-from-array mat) b c+)))
          (is (eql :unbounded (slp-primal! lp))))
        (let* ((lp (make-sparse-lp (make-csc-from-array mat) b c-)))
          (is (eql :optimal (slp-primal! lp))))))))

(defun check (mat b c mat-dual b-dual c-dual lp)
  (multiple-value-bind (obj prim dual)
      (slp-restore lp)
    ;; check primal
    (let ((m (csc-m mat))
          (n (csc-n mat)))
      (let ((lhs (csc-gemv mat (subseq prim 0 (- n m))))
            (obj2 (loop for x across (subseq prim 0 (- n m))
                        for coef across c
                        sum (* x coef))))
        (is (nearly= 1d-8 obj obj2))
        (dotimes (i m)
          (incf (aref lhs i) (aref prim (+ (- n m) i))))
        (is (nearly-equalp 1d-8 lhs b))
        (is (loop for x across prim
                  always (>= x -1d-8))))
      ;; check dual
      (let ((lhs (csc-gemv mat-dual (subseq dual (- n m))))
            (obj2 (loop for y across (subseq dual (- n m))
                        for coef across c-dual
                        sum (* y coef))))
        (dotimes (i (- n m))
          (incf (aref lhs i) (aref dual i)))
        (is (nearly= 1d-8 obj (- obj2)))
        (is (nearly-equalp 1d-8 lhs b-dual))
        (is (loop for x across dual
                  always (>= x -1d-8)))))))

(test sparse-one-phase-simplex/random
  (let ((*random-state* (sb-ext:seed-random-state 0))
        (*test-dribble* nil))
    (labels
        ((proc ()
           (dolist (dim '((2 . 3) (10 . 10) (1 . 1) (10 . 3) (3 . 10)))
             (dolist (rate '(0.1 0.4 0.7 0.9))
               (dotimes (_ 200)
                 (let* ((m (car dim))
                        (n (cdr dim))
                        (mat (make-array (list m n)
                                         :element-type 'double-float
                                         :initial-element 0d0))
                        (mat-dual (make-array (list n m)
                                              :element-type 'double-float
                                              :initial-element 0d0))
                        (b (make-array m :element-type 'double-float :initial-element 0d0))
                        (c (make-array n :element-type 'double-float :initial-element 0d0)))
                   (dotimes (i m)
                     (dotimes (j n)
                       (when (< (random 1d0) rate)
                         (let ((val (float (- (random 20) 10) 1d0)))
                           (setf (aref mat i j) val
                                 (aref mat-dual j i) (- val))))))
                   (dotimes (i m)
                     (setf (aref b i) (float (random 20) 1d0)))
                   (dotimes (j n)
                     (setf (aref c j) (float (- (random 20) 10) 1d0)))
                   (let* ((b- (map '(simple-array double-float (*)) #'- b))
                          (c- (map '(simple-array double-float (*)) #'- c))
                          (csc (make-csc-from-array mat))
                          (csc-dual (make-csc-from-array mat-dual))
                          (lp (make-sparse-lp csc b c))
                          (lp-dual (make-sparse-lp csc-dual c- b-))
                          (result1 (slp-primal! lp))
                          (result2 (slp-dual! lp-dual)))
                     (is (or (and (eql result1 :optimal) (eql result2 :optimal))
                             (and (eql result1 :unbounded) (eql result2 :infeasible))))
                     ;; check sparse-primal!
                     (when (eql result1 :optimal)
                       (check csc b c csc-dual c- b- lp))
                     ;; check sparse-dual!
                     (when (eql result2 :optimal)
                       (check csc-dual c- b- csc b c lp-dual)))))))))
      (let ((*refactor-threshold* 1))
        (proc))
      (let ((*refactor-threshold* 200)
            (*refactor-by-time* nil))
        (proc)))))

(defun choose (vector k)
  (let ((vector (copy-seq vector)))
    (shuffle! vector)
    (subseq vector 0 k)))

(test sparse-two-phase-simplex/random
  (let ((*random-state* (sb-ext:seed-random-state 0))
        (*test-dribble* nil)
        (singular 0)
        (nonsingular 0))
    (labels
        ((proc ()
           (dolist (dim '((2 . 3) (10 . 10) (1 . 1) (10 . 3) (3 . 10)))
             (dolist (rate '(0.1 0.5 0.9))
               (dotimes (_ 200)
                 (let* ((m (car dim))
                        (n (cdr dim))
                        (mat (make-array (list m n)
                                         :element-type 'double-float
                                         :initial-element 0d0))
                        (mat-dual (make-array (list n m)
                                              :element-type 'double-float
                                              :initial-element 0d0))
                        (b (make-array m :element-type 'double-float :initial-element 0d0))
                        (c (make-array n :element-type 'double-float :initial-element 0d0))
                        (cols (make-array (+ n m) :element-type 'fixnum)))
                   (dotimes (i (length cols))
                     (setf (aref cols i) i))
                   (dotimes (i m)
                     (dotimes (j n)
                       (when (< (random 1d0) rate)
                         (let ((val (float (- (random 20) 10) 1d0)))
                           (setf (aref mat i j) val
                                 (aref mat-dual j i) (- val))))))
                   (dotimes (i m)
                     (setf (aref b i) (float (- (random 20) 10) 1d0)))
                   (dotimes (j n)
                     (setf (aref c j) (float (- (random 20) 10) 1d0)))
                   (let* ((basics (choose cols m))
                          (b- (map '(simple-array double-float (*)) #'- b))
                          (c- (map '(simple-array double-float (*)) #'- c))
                          (csc (make-csc-from-array mat))
                          (csc-self (make-csc-from-array mat))
                          (csc-dual (make-csc-from-array mat-dual))
                          (lp (let* ((dictionary (make-dictionary m (+ m n) basics))
                                     (lp (make-sparse-lp csc b c :dictionary dictionary)))
                                (if (= m (lud-rank (lud-eta-lud (slp-lude lp))))
                                    (progn
                                      (incf nonsingular)
                                      lp)
                                    (progn
                                      (incf singular)
                                      (make-sparse-lp csc b c :add-slack nil)))))
                          (lp-dual (make-sparse-lp csc-dual c- b-))
                          (lp-self (let* ((dictionary (make-dictionary m (+ m n) basics))
                                          (lp (make-sparse-lp csc-self b c
                                                              :dictionary dictionary)))
                                     (if (= m (lud-rank (lud-eta-lud (slp-lude lp))))
                                         lp
                                         (make-sparse-lp csc-self b c :add-slack nil)))))
                     (let ((result1 (slp-dual-primal! lp))
                           (result2 (slp-dual-primal! lp-dual))
                           (result-self (slp-self-dual! lp-self)))
                       (cond ((and (eql result1 :optimal) (eql result2 :optimal))
                              (is (eql result-self :optimal)))
                             ((and (eql result1 :unbounded) (eql result2 :infeasible))
                              (is (eql result-self :dual-infeasible)))
                             ((and (eql result1 :infeasible) (eql result2 :unbounded))
                              (is (eql result-self :infeasible)))
                             ((and (eql result1 :infeasible) (eql result2 :infeasible))
                              (is (member result-self '(:infeasible :dual-infeasible)))))
                       ;; check primal problem
                       (when (eql result1 :optimal)
                         (check csc b c csc-dual c- b- lp))
                       ;; check dual problem
                       (when (eql result2 :optimal)
                         (check csc-dual c- b- csc b c lp-dual))
                       ;; check slp-self-dual!
                       (when (eql result-self :optimal)
                         (check csc-self b c csc-dual c- b- lp-self))))))))))
      (let ((*refactor-threshold* 1))
        (proc))
      (let ((*refactor-threshold* 200)
            (*refactor-by-time* nil))
        (proc)
        (is (> singular 1000))
        (is (> nonsingular 1000))))))

(defun test* ()
  (let ((m 5)
        (n 4)
        (rate 1d0)
        (count 0))
    (dotimes (_ 10000)
      (let ((coo (make-coo m n))
            (coo-dual (make-coo n m))
            (b (make-array m :element-type 'double-float :initial-element 0d0))
            (c (make-array n :element-type 'double-float :initial-element 0d0))
            (cols (make-array (+ n m) :element-type 'fixnum)))
        (dotimes (i (length cols))
          (setf (aref cols i) i))
        (dotimes (i m)
          (dotimes (j n)
            (when (< (random 1d0) rate)
              (let ((val (float (- (random 20) 10) 1d0)))
                (coo-insert! coo i j val)
                (coo-insert! coo-dual j i (- val))))))
        (dotimes (i m)
          (setf (aref b i) (float (- (random 20) 10) 1d0)))
        (dotimes (j n)
          (setf (aref c j) (float (- (random 20) 10) 1d0)))
        (let* ((b- (map '(simple-array double-float (*)) #'- b))
               (c- (map '(simple-array double-float (*)) #'- c))
               (basics (choose cols m))
               (csc (make-csc-from-coo coo))
               (csc-dual (make-csc-from-coo coo-dual))
               (lp (make-sparse-lp csc b c :dictionary (make-dictionary m (+ m n) basics)))
               (rank (lud-rank (lud-eta-lud (slp-lude lp)))))
          (when (= m rank)
            (let ((result (slp-dual-primal! lp)))
              (when (eql result :optimal)
                (incf count)
                (multiple-value-bind (obj prim dual) (slp-restore lp)
                  ;; check primal
                  (let ((lhs (csc-gemv csc (subseq prim 0 n)))
                        (obj2 (loop for x across (subseq prim 0 n)
                                    for coef across c
                                    sum (* x coef))))
                    (dotimes (i m)
                      (incf (aref lhs i) (aref prim (+ n i))))
                    (assert (nearly= 1d-5 obj obj2))
                    (assert (nearly-equalp 1d-8 lhs b))
                    (assert (loop for x across prim
                                  always (>= x -1d-5))))
                  (let ((lhs (csc-gemv csc-dual (subseq dual n)))
                        (obj2 (loop for y across (subseq dual n)
                                    for coef across b-
                                    sum (* y coef))))
                    (dotimes (i n)
                      (incf (aref lhs i) (aref dual i)))
                    (assert (nearly= 1d-8 obj (- obj2)))
                    (assert (nearly-equalp 1d-8 lhs c-))
                    (assert (loop for x across dual
                                  always (>= x -1d-8)))))))))))
    count))
