(eval-when (:compile-toplevel :load-toplevel :execute)
  (load "test-util")
  (load "../disjoint-sparse-table.lisp"))

(use-package :test-util)

(with-test (:name disjoint-sparse-table)
  (let ((table (make-disjoint-sparse-table #(1 2 3 4 5) #'*)))
    (assert (= 1 (dst-query table #'* 0 1)))
    (assert (= 2 (dst-query table #'* 0 2)))
    (assert (= 6 (dst-query table #'* 0 3)))
    (assert (= 24 (dst-query table #'* 0 4)))
    (assert (= 120 (dst-query table #'* 0 5)))
    (assert (= 2 (dst-query table #'* 1 2)))
    (assert (= 6 (dst-query table #'* 1 3)))
    (assert (= 24 (dst-query table #'* 1 4)))
    (assert (= 120 (dst-query table #'* 1 5)))
    (assert (= 3 (dst-query table #'* 2 3)))
    (assert (= 12 (dst-query table #'* 2 4)))
    (assert (= 60 (dst-query table #'* 2 5)))
    (assert (= 4 (dst-query table #'* 3 4)))
    (assert (= 20 (dst-query table #'* 3 5)))
    (assert (= 5 (dst-query table #'* 4 5)))
    (assert (null (dst-query table #'* 4 4)))
    (assert (= 0 (dst-query table #'* 4 4 0)))
    (signals error (dst-query table #'* 4 3)))
  ;; no element
  (let ((table0 (make-disjoint-sparse-table #() #'gcd)))
    (assert (equalp #2a(()) table0))
    (assert (zerop (dst-query table0 #'gcd 0 0 0))))
  ;; one element
  (let ((table1 (make-disjoint-sparse-table #(1) #'min)))
    (assert (= 1 (dst-query table1 #'min 0 1)))
    (assert (null (dst-query table1 #'min 0 0))))

  (let* ((state (sb-ext:seed-random-state 0))
         (n 30)
         (seq (apply #'vector (loop repeat n collect (random 1000))))
         (table (make-disjoint-sparse-table seq #'+)))
    (dotimes (l n)
      (loop for r from (+ l 1) to n
	    do (assert (= (loop for i from l below r sum (aref seq i))
                          (dst-query table #'+ l r)))))))

