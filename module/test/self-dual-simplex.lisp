(defpackage :cp/test/self-dual-simplex
  (:use :cl :fiveam :cp/self-dual-simplex :cp/lp-test-tool :cp/test/nearly-equal)
  (:import-from :cp/test/base #:base-suite))
(in-package :cp/test/self-dual-simplex)
(in-suite base-suite)

(test self-dual-simplex/hand
  (let ((*test-dribble* nil)
        (*random-state* (sb-ext:seed-random-state 0))
        (a #2a((-1d0 1d0) (-1d0 -2d0) (0d0 1d0)))
        (b #(-1d0 -2d0 1d0))
        (c #(-2d0 3d0)))
    (dotimes (_ 10)
      (multiple-value-bind (obj res-primal res-dual)
          (self-dual! (copy a) (copy b) (copy c))
        (is (nearly= 1d-8 obj -1d0))
        (is (nearly-equalp 1d-8 res-primal #(2d0 1d0)))
        (is (nearly-equalp 1d-8 res-dual #(2d0 0d0 1d0)))))))

(defconstant +eps+ 1d-8)

(defun check* (a b c)
  (declare (optimize (speed 3))
           ((simple-array double-float (* *)) a)
           ((simple-array double-float (*)) b c))
  (destructuring-bind (m n) (array-dimensions a)
    (declare ((mod #.array-dimension-limit) m n))
    (multiple-value-bind (res prim dual) (self-dual! (copy a) (copy b) (copy c))
      (multiple-value-bind (a* b* c*) (dual-std a b c)
        (multiple-value-bind (res2 prim2 dual2) (self-dual! (copy a*) (copy b*) (copy c*))
          (declare (ignore prim2 dual2))
          (when prim
            (dotimes (i m)
              (let ((lhs 0d0))
                (declare (double-float lhs))
                (dotimes (j n)
                  (incf lhs (* (aref a i j) (aref prim j))))
                (is (<= lhs (+ +eps+ (aref b i)))))))
          (when dual
            (dotimes (i n)
              (let ((lhs 0d0))
                (declare (double-float lhs))
                (dotimes (j m)
                  (incf lhs (* (aref a* i j) (aref dual j))))
                (is (<= lhs (+ +eps+ (aref b* i)))))))
          (if (and (numberp res) (numberp res2))
              (let ((obj1 0d0)
                    (obj2 0d0))
                (declare (double-float obj1 obj2))
                (dotimes (j n)
                  (incf obj1 (* (aref c j) (aref prim j))))
                (dotimes (j m)
                  (incf obj2 (* (aref c* j) (aref dual j))))
                (is (nearly= 1d-8 res (- res2) obj1 (- obj2))))
              (is (not (or (numberp res) (numberp res2))))))))))

(test self-dual-simplex/random
  (let ((*test-dribble* nil)
        (*random-state* (sb-ext:seed-random-state 0)))
    (dotimes (_ 500)
      (multiple-value-bind (a b c)
          (make-random-instance 10d0 :non-negative-b t :round t)
        (check* a b c)))
    (dotimes (_ 500)
      (multiple-value-bind (a b c)
          (make-random-instance 10d0 :non-negative-b nil :round t)
        (check* a b c)))
    ;; small size
    (dotimes (_ 2000)
      (multiple-value-bind (a b c)
          (make-random-instance 10d0 :non-negative-b t :round t :size 1)
        (check* a b c)))
    (dotimes (_ 2000)
      (multiple-value-bind (a b c)
          (make-random-instance 10d0 :non-negative-b nil :round t :size 1)
        (check* a b c)))))
