(defpackage :cp/test/self-dual-simplex
  (:use :cl :fiveam :cp/self-dual-simplex :cp/lp-test-tool :cp/test/nearly-equal)
  (:import-from :cp/test/base #:base-suite))
(in-package :cp/test/self-dual-simplex)
(in-suite base-suite)

(test self-dual-simplex/hand
  (let ((*test-dribble* nil)
        (*random-state* (sb-ext:seed-random-state 0))
        (a #2a((-1d0 1d0) (-1d0 -2d0) (0d0 1d0)))
        (b #(-1d0 -2d0 1d0))
        (c #(-2d0 3d0)))
    (dotimes (_ 10)
      (multiple-value-bind (obj res-primal res-dual)
          (self-dual! (copy a) (copy b) (copy c))
        (is (nearly= 1d-8 obj -1d0))
        (is (nearly-equal 1d-8 (coerce res-primal 'list) '(2d0 1d0)))
        (is (nearly-equal 1d-8 (coerce res-dual 'list) '(2d0 0d0 1d0)))))))

(defconstant +eps+ 1d-8)

(defun check* (a b c)
  (declare (optimize (speed 3))
           ((simple-array double-float (* *)) a)
           ((simple-array double-float (*)) b c))
  (destructuring-bind (m n) (array-dimensions a)
    (declare ((mod #.array-dimension-limit) m n))
    (multiple-value-bind (res prim dual) (self-dual! (copy a) (copy b) (copy c))
      (multiple-value-bind (a* b* c*) (dual-std a b c)
        (multiple-value-bind (res2 prim2 dual2) (self-dual! (copy a*) (copy b*) (copy c*))
          (when prim
            (dotimes (i m)
              (let ((lhs 0d0))
                (declare (double-float lhs))
                (dotimes (j n)
                  (incf lhs (* (aref a i j) (aref prim j))))
                (is (<= lhs (+ +eps+ (aref b i)))))))
          (when dual
            (dotimes (i n)
              (let ((lhs 0d0))
                (declare (double-float lhs))
                (dotimes (j m)
                  (incf lhs (* (aref a* i j) (aref dual j))))
                (is (<= lhs (+ +eps+ (aref b* i)))))))
          (if (and (numberp res) (numberp res2))
              (let ((obj1 0d0)
                    (obj2 0d0))
                (declare (double-float obj1 obj2))
                (dotimes (j n)
                  (incf obj1 (* (aref c j) (aref prim j))))
                (dotimes (j m)
                  (incf obj2 (* (aref c* j) (aref dual j))))
                (is (nearly= 1d-8 res (- res2) obj1 (- obj2))))
              (is (not (or (numberp res) (numberp res2))))))))))

(test self-dual-simplex/random
  (let ((*test-dribble* nil)
        (*random-state* (sb-ext:seed-random-state 0)))
    (dotimes (_ 500)
      (multiple-value-bind (a b c) (make-random-instance 10d0 t t)
        (check* a b c)))
    (dotimes (_ 500)
      (multiple-value-bind (a b c) (make-random-instance 10d0 nil t)
        (check* a b c)))
    ;; small size
    (dotimes (_ 2000)
      (multiple-value-bind (a b c) (make-random-instance 10d0 t t 1)
        (check* a b c)))
    (dotimes (_ 2000)
      (multiple-value-bind (a b c) (make-random-instance 10d0 nil t 1)
        (check* a b c)))))

(defun test* ()
  (let ((a #2A((-13.0d0) (5.0d0) (0.0d0) (-2.0d0)))
        (b #(-3.0d0 5.0d0 -5.0d0 7.0d0))
        (c #(4.0d0)))
    (destructuring-bind  (m n) (array-dimensions a)
      (multiple-value-bind (prim-res dual-res prim dual) 
          (self-dual! (copy a) (copy b) (copy c))
        (multiple-value-bind (a* b* c*) (dual-std a b c)
          (multiple-value-bind (prim-res2 dual-res2 prim2 dual2) (self-dual! (copy a*) (copy b*) (copy c*))
            (when prim2
              (dotimes (i n)
                (let ((lhs 0d0))
                  (declare (double-float lhs))
                  (dotimes (j m)
                    (incf lhs (* (aref a* i j) (aref prim2 j))))
                  (assert (<= lhs (+ +eps+ (aref b* i)))))))
            (when dual
              (dotimes (i n)
                (let ((lhs 0d0))
                  (declare (double-float lhs))
                  (dotimes (j m)
                    (incf lhs (* (aref a* i j) (aref dual j))))
                  (assert (<= lhs (+ +eps+ (aref b* i)))))))
            (values prim-res dual-res prim dual prim-res2 dual-res2 prim2 dual2)))))))



