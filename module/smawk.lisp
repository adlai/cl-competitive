(defpackage :cp/smawk
  (:use :cl)
  (:export #:smawk))
(in-package :cp/smawk)

(declaim (inline smawk))
(defun smawk (function x1 y1 x2 y2 &key (order #'<))
  (declare (fixnum x1 y1 x2 y2))
  (assert (and (<= x1 x2) (<= y1 y2)))
  (let* ((rowlen (- x2 x1))
         (collen (- y2 y1))
         (res (make-array rowlen :element-type 'fixnum))
         (cols (make-array (+ (* 2 rowlen) collen) :element-type 'fixnum)))
    (declare ((mod #.array-total-size-limit) rowlen collen))
    (dotimes (i collen)
      (setf (aref cols i) (+ y1 i)))
    (labels
        ((recur (xinit cstart cend step)
           (declare (fixnum xinit step cstart cend))
           (when (>= xinit x2)
             (return-from recur (make-array 0 :element-type 'fixnum)))
           (let ((rend (ceiling (the fixnum (- x2 xinit)) step))
                 (new-end cend))
             (declare ((mod #.array-total-size-limit) rend new-end))
             (loop
               with x of-type fixnum = (- xinit step)
               for pos from cstart below cend
               for c = (aref cols pos)
               do (loop 
                    while (and (/= new-end cend)
                               (funcall order
                                        (funcall function x c)
                                        (funcall function x (aref cols (- new-end 1)))))
                    do (decf new-end)
                       (decf x step))
                  (when (< (- new-end cend) rend)
                    (setf (aref cols new-end) c)
                    (incf new-end)
                    (incf x step)))
             (recur (+ xinit step) cend new-end (* 2 step))
             (let ((pos cend))
               (declare ((mod #.array-total-size-limit) pos))
               (loop for x of-type fixnum from xinit below x2 by (* 2 step)
                     for end = (if (< (+ x step) x2)
                                   (aref res (- (the fixnum (+ x step)) x1))
                                   (aref cols (- new-end 1)))
                     for col = (aref cols pos)
                     do (loop while (< (aref cols pos) end)
                              do (incf pos)
                              when (funcall order
                                            (funcall function x (aref cols pos))
                                            (funcall function x col))
                              do (setq col (aref cols pos)))
                        (setf (aref res (- x x1)) col))
               res))))
      (recur x1 0 collen 1)
      res)))
