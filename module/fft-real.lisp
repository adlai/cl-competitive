(defpackage :cp/fft-real
  (:use :cl)
  (:export #:fft-float #:fft-vector #:ensure-fft-base!
           #:dft! #:inverse-dft! #:convolve! #:convolve)
  (:documentation
   "Provides real FFT.

Reference:
http://www.kurims.kyoto-u.ac.jp/~ooura/fftman/ftmn2_12.html#sec2_1_2"))
(in-package :cp/fft-real)

(deftype fft-float () 'double-float)
(deftype fft-vector () '(simple-array fft-float (*)))

(declaim (inline power2-p))
(defun power2-p (x)
  "Checks if X is a power of 2."
  (zerop (logand x (- x 1))))

(declaim (fft-vector *cos-table* *sin-table*))
(defparameter *cos-table* (make-array 0 :element-type 'fft-float))
(defparameter *sin-table* (make-array 0 :element-type 'fft-float))

(defun ensure-fft-base! (n)
  "Prepares roots of unity for FFT of length equal to or less than n."
  (declare (optimize (speed 3))
           ((mod #.array-dimension-limit) n))
  (assert (power2-p n))
  (when (> (ash n -2) (length *cos-table*))
    (let ((cos-table (make-array (ash n -2) :element-type 'fft-float))
          (sin-table (make-array (ash n -2) :element-type 'fft-float))
          (theta (/ (coerce (* 2 pi) 'fft-float) n)))
      (dotimes (i (ash n -2))
        (setf (aref cos-table i) (cos (* i theta))
              (aref sin-table i) (sin (* i theta))))
      (setq *cos-table* cos-table
            *sin-table* sin-table))))

(defun dft! (f)
  (declare (optimize (speed 3) (safety 0))
           (fft-vector f))
  (let ((n (length f)))
    (when (zerop n)
      (return-from dft! f))
    (ensure-fft-base! n)
    (let* ((cos-table *cos-table*)
           (sin-table *sin-table*)
           (factor (* 4 (length cos-table))))
      (declare ((mod #.array-dimension-limit) factor))
      ;; bit-reverse ordering
      (let ((i 0))
        (declare ((mod #.array-dimension-limit) i))
        (loop for j from 1 below (- n 1)
              do (loop for k of-type (mod #.array-dimension-limit)
                          = (ash n -1) then (ash k -1)
                       while (> k (setq i (logxor i k))))
                 (when (< j i)
                   (rotatef (aref f i) (aref f j)))))
      (do* ((mh 1 m)
            (m (ash mh 1) (ash mh 1)))
           ((> m n))
        (declare ((mod #.array-dimension-limit) mh m))
        (let ((mq (ash mh -1)))
          (setq factor (ash factor -1))
          (do ((jr 0 (+ jr m)))
              ((>= jr n))
            (declare ((mod #.array-dimension-limit) jr))
            (let ((xreal (aref f (+ jr mh))))
              (setf (aref f (+ jr mh)) (- (aref f jr) xreal))
              (incf (aref f jr) xreal)))
          (do ((i 1 (+ i 1)))
              ((>= i mq))
            (declare ((mod #.array-dimension-limit) i))
            (let* ((index (the fixnum (* factor i)))
                   (wreal (aref cos-table index))
                   (wimag (- (aref sin-table index))))
              (do ((j 0 (+ j m)))
                  ((>= j n))
                (let* ((j+mh (+ j mh))
                       (j+m-i (- (+ j m) i))
                       (xreal (+ (* wreal (aref f (+ j+mh i)))
                                 (* wimag (aref f j+m-i))))
                       (ximag (- (* wreal (aref f j+m-i))
                                 (* wimag (aref f (+ j+mh i))))))
                  (declare ((mod #.array-dimension-limit) j+mh j+m-i))
                  (setf (aref f (+ j+mh i))
                        (+ (- (aref f (- j+mh i))) ximag))
                  (setf (aref f j+m-i)
                        (+ (aref f (- j+mh i)) ximag))
                  (setf (aref f (- j+mh i))
                        (+ (aref f (+ j i)) (- xreal)))
                  (incf (aref f (+ j i)) xreal)))))))))
  f)

(defun inverse-dft! (f)
  (declare (optimize (speed 3) (safety 0))
           (fft-vector f))
  (let ((n (length f)))
    (when (zerop n)
      (return-from inverse-dft! f))
    (ensure-fft-base! n)
    (let* ((cos-table *cos-table*)
           (sin-table *sin-table*)
           (factor (floor (* (length cos-table) 4) n)))
      (declare (fft-vector cos-table sin-table)
               ((mod #.array-dimension-limit) factor))
      (setf (aref f 0) (/ (aref f 0) 2))
      (setf (aref f (ash n -1)) (/ (aref f (ash n -1)) 2))
      (do* ((m n mh)
            (mh (ash m -1) (ash m -1)))
           ((zerop mh))
        (declare ((mod #.array-dimension-limit) m mh))
        (let ((mq (ash mh -1)))
          (do ((jr 0 (+ jr m)))
              ((>= jr n))
            (declare ((mod #.array-dimension-limit) jr))
            (let ((xreal (- (aref f jr) (aref f (+ jr mh)))))
              (incf (aref f jr) (aref f (+ jr mh)))
              (setf (aref f (+ jr mh)) xreal)))
          (do ((i 1 (+ i 1)))
              ((>= i mq))
            (let* ((index (the fixnum (* factor i)))
                   (wreal (aref cos-table index))
                   (wimag (aref sin-table index)))
              (do ((j 0 (+ j m)))
                  ((>= j n))
                (let* ((j+mh (+ j mh))
                       (j+m-i (- (+ j m) i))
                       (xreal (- (aref f (+ j i)) (aref f (- j+mh i))))
                       (ximag (+ (aref f j+m-i) (aref f (+ j+mh i)))))
                  (declare ((mod #.array-dimension-limit) j+mh j+m-i))
                  (incf (aref f (+ j i)) (aref f (- j+mh i)))
                  (setf (aref f (- j+mh i))
                        (- (aref f j+m-i) (aref f (+ j+mh i))))
                  (setf (aref f (+ j+mh i))
                        (+ (* wreal xreal) (* wimag ximag)))
                  (setf (aref f j+m-i)
                        (- (* wreal ximag) (* wimag xreal))))))))
        (setq factor (ash factor 1))))
    ;; bit-reverse ordering
    (let ((i 0))
      (declare ((mod #.array-dimension-limit) i))
      (loop for j from 1 below (- n 1)
            do (loop for k of-type (mod #.array-dimension-limit)
                        = (ash n -1) then (ash k -1)
                     while (> k (setq i (logxor i k))))
               (when (< j i)
                 (rotatef (aref f i) (aref f j)))))
    (let ((scale (* 2 (/ (coerce n 'fft-float)))))
      (dotimes (i n)
        (setf (aref f i) (* (aref f i) scale)))))
  f)

(declaim (inline convolve!))
(defun convolve! (vector1 vector2 &optional result-vector)
  "Returns the convolution of two vectors VECTOR1 and VECTOR2. A new vector is
created when RESULT-VECTOR is null. This function destructively modifies VECTOR1
and VECTOR2. (They can be restored by INVERSE-DFT!.)"
  (declare (fft-vector vector1 vector2)
           ((or null fft-vector) result-vector))
  (let ((n (length vector1)))
    (assert (and (power2-p n)
                 (= n (length vector2))))
    ;; TODO: if (EQ VECTOR1 VECTOR2) holds, the number of FFTs can be reduced.
    ;; TODO: naive convolution for short vectors
    (dft! vector1)
    (dft! vector2)
    (let ((result (or result-vector (make-array n :element-type 'fft-float))))
      (unless (zerop n)
        (incf (aref result 0)
              (* (aref vector1 0) (aref vector2 0)))
        (incf (aref result (ash n -1))
              (* (aref vector1 (ash n -1)) (aref vector2 (ash n -1)))))
      (loop for i from 1 below (ash n -1)
            for value1 of-type fft-float =
               (- (* (aref vector1 i) (aref vector2 i))
                  (* (aref vector1 (- n i)) (aref vector2 (- n i))))
            for value2 of-type fft-float =
               (+ (* (aref vector1 i) (aref vector2 (- n i)))
                  (* (aref vector1 (- n i)) (aref vector2 i)))
            do (setf (aref result i) value1
                     (aref result (- n i)) value2))
      (inverse-dft! result))))

;; KLUDGE: This function depends on SBCL's behaviour. That is, ADJUST-ARRAY
;; isn't guaranteed to preserve a given VECTOR in ANSI CL.
(declaim (ftype (function * (values fft-vector &optional))
                %adjust-array))
(defun %adjust-array (vector length)
  (declare (optimize (speed 3))
           (vector vector)
           ((mod #.array-dimension-limit) length))
  (let ((vector (coerce vector 'fft-vector)))
    (if (= (length vector) length)
        (copy-seq vector)
        (adjust-array vector length :initial-element (coerce 0 'fft-float)))))

(declaim (ftype (function * (values fft-vector &optional))
                convolve))
(defun convolve (vector1 vector2)
  (declare (optimize (speed 3))
           (vector vector1 vector2))
  (let ((len1 (length vector1))
        (len2 (length vector2)))
    (when (or (zerop len1) (zerop len2))
      (return-from convolve (make-array 0 :element-type 'fft-float)))
    (let* ((mul-len (max 0 (- (+ len1 len2) 1)))
           ;; power of two ceiling
           (n (ash 1 (integer-length (max 0 (- mul-len 1)))))
           (vector1 (dft! (%adjust-array vector1 n)))
           (vector2 (dft! (%adjust-array vector2 n)))
           (result (make-array n :element-type 'fft-float)))
      (declare ((mod #.array-dimension-limit) mul-len)
               (fft-vector vector1 vector2))
      (incf (aref result 0)
            (* (aref vector1 0) (aref vector2 0)))
      (incf (aref result (ash n -1))
            (* (aref vector1 (ash n -1)) (aref vector2 (ash n -1))))
      (loop for i from 1 below (ash n -1)
            for value1 of-type fft-float =
               (- (* (aref vector1 i) (aref vector2 i))
                  (* (aref vector1 (- n i)) (aref vector2 (- n i))))
            for value2 of-type fft-float =
               (+ (* (aref vector1 i) (aref vector2 (- n i)))
                  (* (aref vector1 (- n i)) (aref vector2 i)))
            do (setf (aref result i) value1
                     (aref result (- n i)) value2))
      (adjust-array (inverse-dft! result) mul-len))))
