(defpackage :cp/binom-mod-small
  (:use :cl :cp/mod-power :cp/mod-inverse :cp/crt)
  (:export #:make-pnode #:make-pnodes #:%binom #:binom)
  (:documentation
   "Provides computation of binomial coefficient binom(n, k) modulo M, where M
may be composite.

build: O(M)
query: O((log(n))^2 * log(M))"))
(in-package :cp/binom-mod-small)

(defstruct (pnode (:constructor %make-pnode (prime exp p^e table)))
  (prime nil :type (integer 0 #.most-positive-fixnum))
  (exp nil :type (integer 0 #.most-positive-fixnum))
  (p^e nil :type (integer 1 #.most-positive-fixnum))
  (table nil :type (simple-array (integer 0 #.most-positive-fixnum) (*))))

(defun make-pnode (prime exp)
  (declare ((integer 0 #.most-positive-fixnum) prime exp))
  (let* ((mod (expt prime exp))
         (table (make-array mod :element-type '(integer 0 #.most-positive-fixnum))))
    (declare ((integer 0 #.most-positive-fixnum) mod))
    (setf (aref table 0) 1)
    (loop for i from 1 below mod
          do (setf (aref table i)
                   (if (zerop (mod i prime))
                       (aref table (- i 1))
                       (mod (* i (aref table (- i 1))) mod))))
    (%make-pnode prime exp mod table)))

(defun make-pnodes (pfactors)
  (loop for (prime . exp) in pfactors
        collect (make-pnode prime exp)))

(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional))
                %legendre))
(defun %legendre (x p)
  "See https://en.wikipedia.org/wiki/Legendre%27s_formula"
  (declare ((integer 0 #.most-positive-fixnum) x p))
  (loop for denom = p then (* denom p)
        for quot = (floor x denom)
        while (> quot 0)
        sum quot))

(declaim (ftype (function * (values (integer 0 #.most-positive-fixnum) &optional))
                %calc-quasifactorial))
(defun %calc-quasifactorial (x pnode)
  (declare ((integer 0 #.most-positive-fixnum) x))
  (let ((res 1)
        (prime (pnode-prime pnode))
        (p^e (pnode-p^e pnode))
        (table (pnode-table pnode)))
    (declare ((integer 0 #.most-positive-fixnum) res))
    (labels ((calc (x)
               (multiple-value-bind (quot rem) (floor x p^e)
                 (mod (* (mod-power (aref table (- p^e 1)) quot p^e)
                         (aref table rem))
                      p^e))))
      (loop while (> x 0)
            do (setq res (mod (* res (calc x)) p^e)
                     x (floor x prime)))
      res)))

(defun %binom (n k pnode)
  (declare (fixnum n k))
  (when (or (< n 0) (< k 0) (< n k))
    (return-from %binom 0))
  (let* ((p^e (pnode-p^e pnode))
         (prime (pnode-prime pnode))
         (total-exp (- (%legendre n prime)
                       (%legendre k prime)
                       (%legendre (- n k) prime)))
         (res (mod-power (pnode-prime pnode) total-exp p^e)))
    (declare ((integer 0 #.most-positive-fixnum) total-exp res))
    (setq res (mod (* res (%calc-quasifactorial n pnode))
                   p^e)
          res (mod (* res (mod-inverse (%calc-quasifactorial k pnode) p^e))
                   p^e)
          res (mod (* res (mod-inverse (%calc-quasifactorial (- n k) pnode) p^e))
                   p^e))))

(defun binom (n k pnodes)
  (declare (fixnum n k))
  (when (or (< n 0) (< k 0) (< n k))
    (return-from binom 0))
  (let ((value 0)
        (mod 1))
    (declare ((integer 0 #.most-positive-fixnum) value mod))
    (dolist (pnode pnodes)
      (multiple-value-bind (new-value new-mod)
          (crt value mod (%binom n k pnode) (pnode-p^e pnode))
        (setq value new-value
              mod new-mod)))
    value))
