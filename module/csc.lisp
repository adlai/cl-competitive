(defpackage :cp/csc
  (:use :cl)
  (:export #:csc #:make-csc #:csc-to-array #:make-csc-from-array #:make-csc-from-coo
           #:csc-gemv #:csc-gemv-with-basis #:csc-transpose #:csc-m #:csc-n #:csc-nz
           #:csc-colstarts #:csc-rows #:csc-values
           #:sparse-vector #:make-sparse-vector #:make-sparse-vector-from #:to-dense-vector
           #:sparse-vector-nz #:sparse-vector-values #:sparse-vector-indices)
  (:documentation "Provides compressed sparse column representation of sparse
matrix."))
(in-package :cp/csc)

(deftype csc-float () 'double-float)
(defconstant +zero+ (coerce 0 'csc-float))
(defconstant +one+ (coerce 1 'csc-float))

(defstruct (csc (:constructor make-csc (m n nz colstarts rows values))
                (:copier nil)
                (:predicate nil))
  (m nil :type (mod #.array-dimension-limit))
  (n nil :type (mod #.array-dimension-limit))
  (nz nil :type (mod #.array-dimension-limit))
  (colstarts nil :type (simple-array fixnum (*)))
  (rows nil :type (simple-array fixnum (*)))
  (values nil :type (simple-array csc-float (*))))

(defun csc-to-array (csc &optional rowperm colperm)
  (declare (optimize (speed 3))
           ((or null vector) rowperm colperm))
  (let* ((m (csc-m csc))
         (n (csc-n csc))
         (res (make-array (list m n) :element-type 'csc-float :initial-element +zero+))
         (colstarts (csc-colstarts csc))
         (rows (csc-rows csc))
         (values (csc-values csc)))
    (dotimes (col n)
      (let ((dest-col (if colperm (aref colperm col) col)))
        (loop for i from (aref colstarts col) below (aref colstarts (+ col 1))
              for row = (aref rows i)
              for dest-row = (if rowperm (aref rowperm row) row)
              for value = (aref values i)
              do (setf (aref res dest-row dest-col) value))))
    res))

(defun make-csc-from-array (array)
  "Makes CSC from a 2-dimensional array."
  (declare (optimize (speed 3))
           ((array * (* *)) array))
  (destructuring-bind (m n) (array-dimensions array)
    (declare ((mod #.array-dimension-limit) m n))
    (let* ((colstarts (make-array (+ n 1) :element-type 'fixnum))
           (nz (count +zero+ (sb-ext:array-storage-vector array) :test-not #'=))
           (rows (make-array nz :element-type 'fixnum))
           (values (make-array nz :element-type 'csc-float))
           (end 0))
      (declare ((mod #.array-dimension-limit) end))
      (dotimes (col n)
        (setf (aref colstarts col) end)
        (dotimes (row m)
          (let ((value (aref array row col)))
            (unless (zerop value)
              (setf (aref rows end) row
                    (aref values end) value)
              (incf end)))))
      (setf (aref colstarts n) end)
      (make-csc m n nz colstarts rows values))))

(declaim (inline make-csc-from-coo))
(defun make-csc-from-coo (m n rows cols values)
  "Makes CSC from a coordinalte list expression of a sparse matrix.

Note:
- This function uses the element closest to the end if duplicate (row, col) exist.
- The returned CSC contains zero when VALUES contains it."
  (declare (inline stable-sort)
           ((mod #.array-dimension-limit) m n)
           (vector rows cols values))
  (assert (= (length rows) (length cols) (length values)))
  (let* ((indices (let ((tmp (make-array (length rows) :element-type 'fixnum)))
                    (dotimes (i (length rows))
                      (setf (aref tmp i) i))
                    (stable-sort tmp (lambda (i1 i2)
                                       (if (= (aref cols i1) (aref cols i2))
                                           (< (aref rows i1) (aref rows i2))
                                           (< (aref cols i1) (aref cols i2)))))))
         (nz 0))
    (declare ((simple-array fixnum (*)) indices)
             ((mod #.array-dimension-limit) nz))
    ;; drop duplicate elements
    (dotimes (i* (length indices))
      (let ((i (aref indices i*)))
        (if (and (> i* 0)
                 (let ((prev-i (aref indices (- i* 1))))
                   (and (= (aref rows i) (aref rows prev-i))
                        (= (aref cols i) (aref cols prev-i)))))
            (setf (aref indices (- nz 1)) i)
            (setf (aref indices nz) i
                  nz (+ nz 1)))))
    (let ((colstarts (make-array (+ n 1) :element-type 'fixnum))
          (csc-rows (make-array nz :element-type 'fixnum))
          (csc-values (make-array nz :element-type 'csc-float))
          (end 0)
          (prev-col -1))
      (declare ((mod #.array-dimension-limit) end)
               ((integer -1 (#.array-dimension-limit)) prev-col))
      (dotimes (i* nz)
        (let* ((i (aref indices i*))
               (row (aref rows i))
               (col (aref cols i))
               (value (aref values i)))
          (loop for j from col above prev-col
                do (setf (aref colstarts j) end))
          (setf (aref csc-rows end) row
                (aref csc-values end) value)
          (incf end)
          (setq prev-col col)))
      (loop for j from n above prev-col
            do (setf (aref colstarts j) end))
      (make-csc m n nz colstarts csc-rows csc-values))))

(declaim (inline csc-gemv-with-basis))
(defun csc-gemv-with-basis (csc vector basis)
  (declare (vector vector basis))
  (let* ((m (csc-m csc))
         (colstarts (csc-colstarts csc))
         (rows (csc-rows csc))
         (values (csc-values csc))
         (res (make-array m :element-type 'csc-float :initial-element +zero+)))
    (dotimes (i m)
      (let ((bi (aref basis i)))
        (loop for k from (aref colstarts bi) below (aref colstarts (+ bi 1))
              do (incf (aref res (aref rows k))
                       (* (aref values k) (float (aref vector i) 1d0))))))
    res))

(declaim (inline csc-gemv))
(defun csc-gemv (csc vector)
  (declare (vector vector))
  (let* ((m (csc-m csc))
         (n (csc-n csc))
         (colstarts (csc-colstarts csc))
         (rows (csc-rows csc))
         (values (csc-values csc))
         (res (make-array m :element-type 'csc-float :initial-element +zero+)))
    (dotimes (j n)
      (loop for k from (aref colstarts j) below (aref colstarts (+ j 1))
            do (incf (aref res (aref rows k))
                     (* (aref values k) (float (aref vector j) 1d0)))))
    res))

(defun csc-transpose (csc)
  "Returns the transposed matrix of CSC. This function is non-destructive."
  (declare (optimize (speed 3)))
  (let* ((m (csc-m csc))
         (n (csc-n csc))
         (nz (csc-nz csc))
         (colstarts (csc-colstarts csc))
         (rows (csc-rows csc))
         (values (csc-values csc))
         (tmp (make-array m :element-type 'fixnum :initial-element 0))
         (new-colstarts (make-array (+ m 1) :element-type 'fixnum :initial-element 0))
         (new-rows (make-array nz :element-type 'fixnum :initial-element 0))
         (new-values (make-array nz :element-type 'csc-float :initial-element +zero+)))
    (dotimes (k nz)
      (let ((row (aref rows k)))
        (incf (aref tmp row))))
    ;; TMP[ROW] == the number of the elements in ROW
    (dotimes (i m)
      (setf (aref new-colstarts (+ i 1))
            (+ (aref new-colstarts i) (aref tmp i))))
    (fill tmp 0)
    (dotimes (j n)
      (loop for k from (aref colstarts j) below (aref colstarts (+ j 1))
            for row = (aref rows k)
            for new-pos = (+ (aref new-colstarts row) (aref tmp row))
            do (incf (aref tmp row))
               (setf (aref new-rows new-pos) j
                     (aref new-values new-pos) (aref values k))))
    (make-csc n m nz new-colstarts new-rows new-values)))

(defstruct (sparse-vector (:constructor %make-sparse-vector (nz values indices)))
  (nz nil :type (mod #.array-dimension-limit))
  (values nil :type (simple-array csc-float (*)))
  (indices nil :type (simple-array fixnum (*))))

(defun make-sparse-vector (size)
  (%make-sparse-vector
   0
   (make-array size :element-type 'csc-float)
   (make-array size :element-type 'fixnum)))

(defun make-sparse-vector-from (vector)
  (declare (vector vector))
  (let* ((nz (count +zero+ vector :test-not #'=))
         (values (make-array nz :element-type 'csc-float))
         (indices (make-array nz :element-type 'fixnum))
         (end 0))
    (declare ((mod #.array-dimension-limit) end))
    (dotimes (i (length vector))
      (unless (zerop (aref vector i))
        (setf (aref values end) (aref vector i)
              (aref indices end) i)
        (incf end)))
    (%make-sparse-vector nz values indices)))

(defun to-dense-vector (sparse-vector)
  (let* ((nz (sparse-vector-nz sparse-vector))
         (indices (sparse-vector-indices sparse-vector))
         (values (sparse-vector-values sparse-vector))
         (m (if (zerop (length indices))
                0
                (+ 1 (reduce #'max indices))))
         (res (make-array m :element-type 'csc-float :initial-element +zero+)))
    (dotimes (i nz)
      (let ((index (aref indices i))
            (value (aref values i)))
        (setf (aref res index) value)))
    res))
