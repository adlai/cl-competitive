(defpackage :cp/fps-sqrt
  (:use :cl :cp/mod-inverse :cp/static-mod :cp/mod-sqrt :cp/fps)
  (:export #:fps-sqrt)
  (:import-from :cp/fps #:ntt! #:inverse-ntt!))
(in-package :cp/fps-sqrt)


(defconstant +inv2+ (ash (+ +mod+ 1) -1))
(defconstant +inv-2+ (mod (- +inv2+) +mod+))

(declaim (ftype (function * (values (or null mint-vector) &optional)) fps-sqrt %fps-sqrt))
;; (defun %fps-sqrt (poly result-length)
;;   (declare (optimize (speed 3))
;;            (mint-vector poly)
;;            ((mod #.array-dimension-limit) result-length))
;;   (let ((sqrt (mod-sqrt (aref poly 0) +mod+)))
;;     (when sqrt
;;       (assert (= (aref poly 0) (mod (* sqrt sqrt) +mod+)))
;;       (let ((res (make-array 1 :element-type 'mint :initial-element sqrt)))
;;         (loop for len of-type (mod #.array-dimension-limit) = 1 then (ash len 1)
;;               while (< len result-length)
;;               do (let* ((next-len (ash len 1))
;;                         (tmp (poly-prod (poly-inverse res next-len)
;;                                         (%adjust poly next-len))))
;;                    (declare ((mod #.array-dimension-limit) next-len))
;;                    (setq res (%adjust res next-len))
;;                    (dotimes (i next-len)
;;                      (setf (aref res i)
;;                            (mod (* +inv2+ (mod (+ (aref res i) (aref tmp i)) +mod+))
;;                                 +mod+)))))
;;         (%adjust res result-length)))))

(defun %fps-sqrt (poly result-length)
  (declare (optimize (speed 3))
           (mint-vector poly)
           ((mod #.array-dimension-limit) result-length))
  (let ((sqrt (mod-sqrt (aref poly 0) +mod+)))
    (when sqrt
      (assert (and (not (zerop sqrt))
                   (= (aref poly 0) (mod (* sqrt sqrt) +mod+))))
      (let ((res (make-array result-length :element-type 'mint :initial-element 0))
            (tt (make-array result-length :element-type 'mint :initial-element 0))
            (dp (make-array 1 :element-type 'mint :initial-element sqrt)))
        (setf (aref res 0) sqrt
              (aref tt 0) (mod-inverse sqrt +mod+))
        (loop
          for len of-type (mod #.array-dimension-limit) = 1 then (ash len 1)
          while (< len result-length)
          do (dotimes (i len)
               (setf (aref dp i) (mod (expt (aref dp i) 2) +mod+)))
             (inverse-ntt! dp t)
             (let* ((next-len (ash len 1))
                    (tmp (make-array next-len :element-type 'mint :initial-element 0))
                    (tmp2 (make-array next-len :element-type 'mint :initial-element 0)))
               (declare ((mod #.array-dimension-limit) next-len))
               (replace tmp dp :start1 len)
               (dotimes (i (min (length poly) len))
                 (setf (aref tmp (+ i len))
                       (mod (- (aref tmp (+ i len)) (aref poly i))
                            +mod+)))
               (dotimes (i (min (- (length poly) len) len))
                 (setf (aref tmp (+ i len))
                       (mod (- (aref tmp (+ i len)) (aref poly (+ i len)))
                            +mod+)))
               (ntt! tmp)
               (replace tmp2 tt :end1 len)
               (ntt! tmp2)
               (dotimes (i next-len)
                 (setf (aref tmp i) (mod (* (aref tmp i) (aref tmp2 i)) +mod+)))
               (inverse-ntt! tmp t)
               (loop for i from len below (min next-len result-length)
                     do (setf (aref res i)
                              (mod (* (aref tmp i) +inv-2+) +mod+)))
               (when (>= next-len result-length)
                 (return))
               (setq dp (subseq res 0 next-len))
               (ntt! dp)
               (dotimes (i next-len)
                 (setf (aref tmp i) (mod (* (aref dp i) (aref tmp2 i)) +mod+)))
               (inverse-ntt! tmp t)
               (fill tmp 0 :end len)
               (ntt! tmp)
               (dotimes (i next-len)
                 (setf (aref tmp i) (mod (* (aref tmp i) (aref tmp2 i)) +mod+)))
               (inverse-ntt! tmp t)
               (loop for i from len below next-len
                     do (setf (aref tt i) (mod (- (aref tmp i)) +mod+)))))
        res))))

(defun fps-sqrt (poly &optional result-length)
  (declare (optimize (speed 3))
           (vector poly)
           ((or null (mod #.array-dimension-limit)) result-length))
  (let* ((result-length (or result-length (length poly)))
         (poly (coerce poly 'mint-vector)))
    (labels ((return-zero ()
               (return-from fps-sqrt
                 (make-array result-length :element-type 'mint :initial-element 0))))
      (when (or (zerop (length poly))
                (zerop result-length))
        (return-zero))
      (if (zerop (aref poly 0))
          (let ((i (position 0 poly :test-not #'=)))
            (unless i
              (return-zero))
            (when (oddp i)
              (return-from fps-sqrt))
            (when (<= result-length (ash i -1))
              (return-zero))
            (let ((tmp-res (%fps-sqrt (subseq poly i) (- result-length (ash i -1)))))
              (unless tmp-res
                (return-from fps-sqrt))
              (let ((res (make-array result-length :element-type 'mint :initial-element 0)))
                (replace res tmp-res :start1 (ash i -1))
                res)))
          (%poly-sqrt poly result-length)))))
