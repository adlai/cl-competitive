;;;
;;; Farthest neighbor points in D-dimensional L1 space (O(2^D N))
;;;

(defpackage :cp/manhattan-fnn
  (:use :cl)
  (:export #:calc-fnn))
(in-package :cp/manhattan-fnn)

(defconstant +neg-inf+ most-negative-fixnum)
(defconstant +pos-inf+ most-positive-fixnum)

(declaim (ftype (function * (values (simple-array fixnum (*))
                                    (simple-array fixnum (*))
                                    &optional))
                calc-fnn))
(defun calc-fnn (points)
  "Returns two vectors, FNN and DIST. FNN[i] stores an index of FNN of POINTS[i] and
DIST[i] stores the distance between i and FNN[i]."
  (declare (optimize (speed 3))
           (vector points))
  (when (zerop (length points))
    (return-from calc-fnn
      (values (make-array 0 :element-type 'fixnum)
              (make-array 0 :element-type 'fixnum))))
  (let* ((dim (length (the vector (aref points 0))))
         (n (length points))
         (signs (make-array dim :element-type 'bit :initial-element 0))
         (values (make-array n :element-type 'fixnum :initial-element 0))
         (maxs (make-array n :element-type 'fixnum :initial-element +neg-inf+))
         (result (make-array n :element-type 'fixnum)))
    (declare ((mod #.array-total-size-limit) dim n))
    (labels ((calc (i)
               (let ((point (aref points i))
                     (value 0))
                 (declare (fixnum value))
                 (dotimes (j dim value)
                   (if (= 1 (aref signs j))
                       (decf value (the fixnum (aref point j)))
                       (incf value (the fixnum (aref point j)))))))
             (main ()
               (let ((min +pos-inf+)
                     argmin)
                 (dotimes (i n)
                   (setf (aref values i) (calc i))
                   (when (< (aref values i) min)
                     (setq min (aref values i)
                           argmin i)))
                 (dotimes (i n)
                   (let ((dist (- (aref values i) min)))
                     (when (> dist (aref maxs i))
                       (setf (aref maxs i) dist
                             (aref result i) argmin))))))
             (dfs (pos)
               (declare ((mod #.array-total-size-limit) pos))
               (if (= pos dim)
                   (main)
                   (progn
                     (setf (aref signs pos) 0)
                     (dfs (+ pos 1))
                     (setf (aref signs pos) 1)
                     (dfs (+ pos 1))))))
      (declare (ftype (function * (values t &optional)) calc main dfs))
      (dfs 0)
      (values result maxs))))
