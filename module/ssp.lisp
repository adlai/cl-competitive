(defpackage :cp/ssp
  (:use :cl :cp/min-cost-flow)
  (:export #:min-cost-flow!))
(in-package :cp/ssp)

;; binary heap for Dijkstra's algorithm
(defstruct (heap (:constructor make-heap
                     (size
                      &aux (costs (make-array (1+ size) :element-type 'cost-type))
                           (vertices (make-array (1+ size) :element-type 'fixnum))))
                 (:copier nil)
                 (:predicate nil))
  (costs nil :type (simple-array cost-type (*)))
  (vertices nil :type (simple-array fixnum (*)))
  (position 1 :type (integer 1 #.most-positive-fixnum)))

(defun heap-push (cost vertex heap)
  (declare (optimize (speed 3)))
  (symbol-macrolet ((position (heap-position heap)))
    (when (>= position (length (heap-costs heap)))
      (setf (heap-costs heap)
            (adjust-array (heap-costs heap) (* position 2))
            (heap-vertices heap)
            (adjust-array (heap-vertices heap) (* position 2))))
    (let ((costs (heap-costs heap))
          (vertices (heap-vertices heap)))
      (labels ((heapify (pos)
                 (declare (optimize (safety 0)))
                 (unless (= pos 1)
                   (let ((parent-pos (ash pos -1)))
                     (when (< (aref costs pos) (aref costs parent-pos))
                       (rotatef (aref costs pos) (aref costs parent-pos))
                       (rotatef (aref vertices pos) (aref vertices parent-pos))
                       (heapify parent-pos))))))
        (setf (aref costs position) cost
              (aref vertices position) vertex)
        (heapify position)
        (incf position)
        heap))))

(defun heap-pop (heap)
  (declare (optimize (speed 3)))
  (symbol-macrolet ((position (heap-position heap)))
    (let ((costs (heap-costs heap))
          (vertices (heap-vertices heap)))
      (labels ((heapify (pos)
                 (declare (optimize (safety 0))
                          ((integer 1 #.most-positive-fixnum) pos))
                 (let* ((child-pos1 (+ pos pos))
                        (child-pos2 (1+ child-pos1)))
                   (when (<= child-pos1 position)
                     (if (<= child-pos2 position)
                         (if (< (aref costs child-pos1) (aref costs child-pos2))
                             (unless (< (aref costs pos) (aref costs child-pos1))
                               (rotatef (aref costs pos) (aref costs child-pos1))
                               (rotatef (aref vertices pos) (aref vertices child-pos1))
                               (heapify child-pos1))
                             (unless (< (aref costs pos) (aref costs child-pos2))
                               (rotatef (aref costs pos) (aref costs child-pos2))
                               (rotatef (aref vertices pos) (aref vertices child-pos2))
                               (heapify child-pos2)))
                         (unless (< (aref costs pos) (aref costs child-pos1))
                           (rotatef (aref costs pos) (aref costs child-pos1))
                           (rotatef (aref vertices pos) (aref vertices child-pos1))))))))
        (multiple-value-prog1 (values (aref costs 1) (aref vertices 1))
          (decf position)
          (setf (aref costs 1) (aref costs position)
                (aref vertices 1) (aref vertices position))
          (heapify 1))))))

(declaim (inline heap-empty-p))
(defun heap-empty-p (heap)
  (= (heap-position heap) 1))

(declaim (inline heap-reinitialize))
(defun heap-reinitialize (heap)
  (setf (heap-position heap) 1)
  heap)

(defmacro the-cost-type (form)
  (reduce (lambda (x y) `(,(car form) (the cost-type ,x) (the cost-type ,y)))
          (cdr form)))

(defun min-cost-flow! (graph src-idx dest-idx flow &key edge-count (if-overflow :error) bellman-ford)
  "Returns the minimum cost to send FLOW units from SRC-IDX to DEST-IDX in
GRAPH. This function destructively modifies GRAPH.

EDGE-COUNT := initial reserved size for heap (it should be the number of edges)
IF-OVERFLOW := :error | nil

If BELLMAN-FORD is true, this function does Bellman-Ford before all. It should
be enabled for a graph that contains negative edges: Currently this function
returns a correct result for a graph that contains negative edges, even when
BELLMAN-FORD is disabled (only if no negative **cycles** are contained, of
course). In this case, however, the worst-case time complexity is
exponential.

As a special case, if an input network is for a weighted bipartite matching that
contains negative weights, this function works without Bellman-Ford."
  (declare (optimize (speed 3))
           ((integer 0 #.most-positive-fixnum) flow src-idx dest-idx)
           ((simple-array list (*)) graph))
  (let* ((size (length graph))
         (edge-count (or edge-count (* size 2)))
         (prev-vertices (make-array size :element-type 'fixnum :initial-element 0))
         (prev-edges (locally
                         (declare (sb-ext:muffle-conditions style-warning))
                       (make-array size :element-type 'cedge)))
         (potential (make-array size :element-type 'cost-type :initial-element 0))
         (dists (make-array size :element-type 'cost-type))
         (pqueue (make-heap edge-count))
         (res 0))
    (declare (fixnum edge-count)
             (cost-type res))
    (labels ((update-potential ()
               (when (= (aref dists dest-idx) +inf-cost+)
                 (if if-overflow
                     (error 'not-enough-capacity-error :flow flow :graph graph :score res)
                     (return-from min-cost-flow! res)))
               (dotimes (v size)
                 (setf (aref potential v)
                       (min +inf-cost+ (+ (aref potential v) (aref dists v)))))))
      (when bellman-ford
        (fill dists +inf-cost+)
        (setf (aref dists src-idx) 0)
        (dotimes (_ (- size 1))
          (dotimes (v size)
            (let ((dist (aref dists v)))
              (when (< dist +inf-cost+)
                (dolist (cedge (aref graph v))
                  (when (> (cedge-capacity cedge) 0)
                    (let ((to (cedge-to cedge)))
                      (setf (aref dists to)
                            (min (aref dists to) (+ dist (cedge-cost cedge)))))))))))
        (update-potential))
      (loop (when (<= flow 0)
              (return-from min-cost-flow! res))
            (fill dists +inf-cost+)
            (setf (aref dists src-idx) 0)
            (heap-reinitialize pqueue)
            (heap-push 0 src-idx pqueue)
            (loop until (heap-empty-p pqueue)
                  do (multiple-value-bind (cost v) (heap-pop pqueue)
                       (declare (cost-type cost)
                                (fixnum v))
                       (when (<= cost (aref dists v))
                         (dolist (edge (aref graph v))
                           (let* ((next-v (cedge-to edge))
                                  (next-cost (the-cost-type
                                              (+ (aref dists v)
                                                 (cedge-cost edge)
                                                 (aref potential v)
                                                 (- (aref potential next-v))))))
                             (when (and (> (cedge-capacity edge) 0)
                                        (> (aref dists next-v) next-cost))
                               (setf (aref dists next-v) next-cost
                                     (aref prev-vertices next-v) v
                                     (aref prev-edges next-v) edge)
                               (heap-push next-cost next-v pqueue)))))))
            (update-potential)
            (let ((max-flow flow))
              (declare ((integer 0 #.most-positive-fixnum) max-flow))
              (do ((v dest-idx (aref prev-vertices v)))
                  ((= v src-idx))
                (setq max-flow (min max-flow (cedge-capacity (aref prev-edges v)))))
              (decf flow max-flow)
              (incf res (the cost-type (* max-flow (aref potential dest-idx))))
              (do ((v dest-idx (aref prev-vertices v)))
                  ((= v src-idx))
                (decf (cedge-capacity (aref prev-edges v)) max-flow)
                (incf (cedge-capacity (cedge-reversed (aref prev-edges v))) max-flow)))))
    (error "Reached unreachable line")))
