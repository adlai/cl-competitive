(defpackage :cp/ssp
  (:use :cl :cp/min-cost-flow)
  (:export #:min-cost-flow!))
(in-package :cp/ssp)

;; binary heap for Dijkstra's algorithm
(defstruct (heap (:constructor make-heap
                     (size
                      &aux (costs (make-array (1+ size) :element-type 'cost-type))
                           (vertices (make-array (1+ size) :element-type 'fixnum)))))
  (costs nil :type (simple-array cost-type (*)))
  (vertices nil :type (simple-array fixnum (*)))
  (position 1 :type (integer 1 #.most-positive-fixnum)))

(defun heap-push (cost vertex heap)
  (declare (optimize (speed 3)))
  (symbol-macrolet ((position (heap-position heap)))
    (when (>= position (length (heap-costs heap)))
      (setf (heap-costs heap)
            (adjust-array (heap-costs heap) (* position 2))
            (heap-vertices heap)
            (adjust-array (heap-vertices heap) (* position 2))))
    (let ((costs (heap-costs heap))
          (vertices (heap-vertices heap)))
      (labels ((update (pos)
                 (declare (optimize (safety 0)))
                 (unless (= pos 1)
                   (let ((parent-pos (ash pos -1)))
                     (when (< (aref costs pos) (aref costs parent-pos))
                       (rotatef (aref costs pos) (aref costs parent-pos))
                       (rotatef (aref vertices pos) (aref vertices parent-pos))
                       (update parent-pos))))))
        (setf (aref costs position) cost
              (aref vertices position) vertex)
        (update position)
        (incf position)
        heap))))

(defun heap-pop (heap)
  (declare (optimize (speed 3)))
  (symbol-macrolet ((position (heap-position heap)))
    (let ((costs (heap-costs heap))
          (vertices (heap-vertices heap)))
      (labels ((update (pos)
                 (declare (optimize (safety 0))
                          ((integer 1 #.most-positive-fixnum) pos))
                 (let* ((child-pos1 (+ pos pos))
                        (child-pos2 (1+ child-pos1)))
                   (when (<= child-pos1 position)
                     (if (<= child-pos2 position)
                         (if (< (aref costs child-pos1) (aref costs child-pos2))
                             (unless (< (aref costs pos) (aref costs child-pos1))
                               (rotatef (aref costs pos) (aref costs child-pos1))
                               (rotatef (aref vertices pos) (aref vertices child-pos1))
                               (update child-pos1))
                             (unless (< (aref costs pos) (aref costs child-pos2))
                               (rotatef (aref costs pos) (aref costs child-pos2))
                               (rotatef (aref vertices pos) (aref vertices child-pos2))
                               (update child-pos2)))
                         (unless (< (aref costs pos) (aref costs child-pos1))
                           (rotatef (aref costs pos) (aref costs child-pos1))
                           (rotatef (aref vertices pos) (aref vertices child-pos1))))))))
        (multiple-value-prog1 (values (aref costs 1) (aref vertices 1))
          (decf position)
          (setf (aref costs 1) (aref costs position)
                (aref vertices 1) (aref vertices position))
          (update 1))))))

(declaim (inline heap-empty-p))
(defun heap-empty-p (heap)
  (= (heap-position heap) 1))

(declaim (inline heap-reinitialize))
(defun heap-reinitialize (heap)
  (setf (heap-position heap) 1)
  heap)

(defun min-cost-flow! (graph src-idx dest-idx flow &key edge-count)
  "Returns the minimum cost to send FLOW units from SRC-IDX to DEST-IDX in
GRAPH. Destructively modifies GRAPH.

EDGE-COUNT := initial reserved size for heap (it should be the number of edges)"
  (declare (optimize (speed 3))
           ((integer 0 #.most-positive-fixnum) flow)
           ((simple-array list (*)) graph))
  (macrolet ((the-cost-type (form)
               (reduce (lambda (x y) `(,(car form) (the cost-type ,x) (the cost-type ,y)))
		       (cdr form))))
    (let* ((size (length graph))
           (edge-count (or edge-count (* size 2)))
           (prev-vertices (make-array size :element-type 'fixnum :initial-element 0))
           (prev-edges (locally
                           (declare (sb-ext:muffle-conditions style-warning))
                         (make-array size :element-type 'cedge)))
           (potential (make-array size :element-type 'cost-type :initial-element 0))
           (dist (make-array size :element-type 'cost-type))
           (pqueue (make-heap edge-count))
           (res 0))
      (declare (fixnum edge-count)
               (cost-type res))
      ;; FIXME: Actually we must do Bellman-Ford here to handle negative edges
      ;; properly. Currently this function returns a correct result also for a
      ;; graph containing negative edges, if no negative **cycles** are
      ;; contained. In this case, however, the worst-case time complexity is
      ;; exponential. If the input network is for a weighted bipartite matching
      ;; containing negative weights, this function completely works without any
      ;; problems.
      (loop while (> flow 0)
            do (fill dist +inf-cost+)
               (setf (aref dist src-idx) 0)
               (heap-reinitialize pqueue)
               (heap-push 0 src-idx pqueue)
               (loop until (heap-empty-p pqueue)
                     do (multiple-value-bind (cost v) (heap-pop pqueue)
                          (declare (cost-type cost)
                                   (fixnum v))
                          (when (<= cost (aref dist v))
                            (dolist (edge (aref graph v))
                              (let* ((next-v (cedge-to edge))
                                     (next-cost (the-cost-type
                                                 (+ (aref dist v)
                                                    (cedge-cost edge)
                                                    (aref potential v)
                                                    (- (aref potential next-v))))))
                                (when (and (> (cedge-capacity edge) 0)
                                           (> (aref dist next-v) next-cost))
                                  (setf (aref dist next-v) next-cost
                                        (aref prev-vertices next-v) v
                                        (aref prev-edges next-v) edge)
                                  (heap-push next-cost next-v pqueue)))))))
               (when (= (aref dist dest-idx) +inf-cost+)
                 (error 'not-enough-capacity-error :flow flow :graph graph :score res))
               (let ((max-flow flow))
                 (declare (fixnum max-flow))
                 (dotimes (v size)
                   (setf (aref potential v)
                         (min +inf-cost+
                              (+ (aref potential v) (aref dist v)))))
                 (do ((v dest-idx (aref prev-vertices v)))
                     ((= v src-idx))
                   (setf max-flow (min max-flow (cedge-capacity (aref prev-edges v)))))
                 (decf flow max-flow)
                 (incf res (the cost-type (* max-flow (aref potential dest-idx))))
                 (do ((v dest-idx (aref prev-vertices v)))
                     ((= v src-idx))
                   (decf (cedge-capacity (aref prev-edges v)) max-flow)
                   (incf (cedge-capacity (cedge-reversed (aref prev-edges v))) max-flow))))
      res)))
