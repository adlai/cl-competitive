(defpackage :cp/self-dual-simplex
  (:use :cl)
  (:export #:self-dual!)
  (:documentation "Provides parametric self-dual simplex method for dense instance.

Reference:
Robert J. Vanderbei. Linear Programming: Foundations and Extensions. 5th edition."))
(in-package :cp/self-dual-simplex)

(deftype simplex-float () 'double-float)
(defconstant +zero+ (coerce 0 'simplex-float))
(defconstant +eps+ 1d-8)
(defconstant +neg-inf+ most-negative-double-float)
(defconstant +pos-inf+ most-positive-double-float)

;; dict: col(0), col(1), ...., col(n-1), row(0), row(1), ..., row(m-1)
;;      |---------- non-basic ---------| |---------- basic ----------|

(defun %restore (b c dict)
  (declare (optimize (speed 3))
           ((simple-array simplex-float (*)) b c)
           ((simple-array fixnum (*)) dict))
  (let* ((m (length b))
         (n (length c))
         (res-primal (make-array n :element-type 'simplex-float :initial-element +zero+))
         (res-dual (make-array m :element-type 'simplex-float :initial-element +zero+)))
    (dotimes (i m)
      (let ((index (aref dict (+ n i))))
        (when (< index n)
          (setf (aref res-primal index) (aref b i)))))
    (dotimes (j n)
      (let ((index (aref dict j)))
        (when (>= index n)
          (setf (aref res-dual (- index n)) (- (aref c j))))))
    (values res-primal res-dual)))

(declaim (ftype (function * (values simplex-float &optional)) %pivot))
(defun %pivot (row col a b c arow acol dict &optional b2 c2)
  (declare (optimize (speed 3))
           ((mod #.array-dimension-limit) row col)
           ((simple-array simplex-float (* *)) a)
           ((simple-array simplex-float (*)) b c arow acol)
           ((or null (simple-array simplex-float (*))) b2 c2)
           ((simple-array fixnum (*)) dict))
  (destructuring-bind (m n) (array-dimensions a)
    (declare ((mod #.array-dimension-limit) m n))
    (rotatef (aref dict col) (aref dict (+ n row)))
    (let* ((apivot (aref a row col))
           (/apivot (/ apivot)))
      (dotimes (i m)
        (dotimes (j n)
          (decf (aref a i j) (* (aref acol i) (aref arow j) /apivot))))
      (dotimes (j n)
        (setf (aref a row j) (* (aref arow j) /apivot)))
      (dotimes (i m)
        (setf (aref a i col) (- (* (aref acol i) /apivot))))
      (setf (aref a row col) /apivot)
      (let ((brow (aref b row))
            (brow2 (aref b2 row)))
        (dotimes (i m)
          (decf (aref b i) (* brow (aref acol i) /apivot))
          (decf (aref b2 i) (* brow2 (aref acol i) /apivot)))
        (setf (aref b row) (* brow /apivot)
              (aref b2 row) (* brow2 /apivot))
        (let ((ccol (aref c col))
              (ccol2 (aref c2 col)))
          (dotimes (j n)
            (decf (aref c j) (* ccol (aref arow j) /apivot))
            (decf (aref c2 j) (* ccol2 (aref arow j) /apivot)))
          (setf (aref c col) (- (* ccol /apivot))
                (aref c2 col) (- (* ccol2 /apivot)))
          (* ccol brow /apivot))))))

(declaim (ftype (function * (values (or simplex-float (member :dual-infeasible :infeasible))
                                    (or null (simple-array simplex-float (*)))
                                    (or null (simple-array simplex-float (*)))
                                    &optional))
                self-dual!))
(defun self-dual! (a b c &optional dict)
  (declare (optimize (speed 3))
           ((simple-array simplex-float (* *)) a)
           ((simple-array simplex-float (*)) b c)
           ((or null (simple-array fixnum (*))) dict))
  (destructuring-bind (m n) (array-dimensions a)
    (declare ((mod #.array-dimension-limit) m n))
    (let ((acol (make-array m :element-type 'simplex-float))
          (arow (make-array n :element-type 'simplex-float))
          (cparams (make-array n :element-type 'simplex-float))
          (bparams (make-array m :element-type 'simplex-float))
          (dict (or dict (make-array (+ n m) :element-type 'fixnum)))
          (obj +zero+))
      (declare (simplex-float obj))
      (dotimes (i (+ n m))
        (setf (aref dict i) i))
      (dotimes (j n)
        (setf (aref cparams j) (+ 0.5d0 (random 1d0))))
      (dotimes (i m)
        (setf (aref bparams i) (+ 0.5d0 (random 1d0))))
      (loop
        (let ((mu-lo +neg-inf+)
              index)
          (dotimes (j n)
            (when (> (aref cparams j) +eps+)
              (let ((lo (/ (aref c j) (aref cparams j))))
                (when (> lo mu-lo)
                  (setq mu-lo lo
                        index j)))))
          (dotimes (i m)
            (when (> (aref bparams i) +eps+)
              (let ((lo (/ (- (aref b i)) (aref bparams i))))
                (when (> lo mu-lo)
                  (setq mu-lo lo
                        index (+ i n))))))
          (when (<= mu-lo +eps+)
            (return))
          (if (>= index n)
              ;; dual pivotting
              (let ((row (- index n)))
                (dotimes (j n)
                  (setf (aref arow j) (aref a row j)))
                (unless (find-if (lambda (x) (< x (- +eps+))) arow)
                  (return-from self-dual! (values :infeasible nil nil)))
                (let (col
                      (colmin +pos-inf+))
                  (dotimes (j n)
                    (when (< (aref arow j) (- +eps+))
                      (let ((rate (/ (- (aref c j) (* (aref cparams j) mu-lo))
                                     (aref arow j))))
                        (when (< rate colmin)
                          (setq col j
                                colmin rate)))))
                  (unless col
                    (error "Pivot not found in row ~A." arow))
                  (dotimes (i m)
                    (setf (aref acol i) (aref a i col)))
                  (incf obj (%pivot row col a b c arow acol dict bparams cparams))))
              ;; primal pivotting
              (let ((col index))
                (dotimes (i m)
                  (setf (aref acol i) (aref a i col)))
                (unless (find-if (lambda (x) (> x +eps+)) acol)
                  (return-from self-dual! (values :dual-infeasible nil nil)))
                (let (row
                      (rowmin +pos-inf+))
                  (dotimes (i m)
                    (when (> (aref acol i) +eps+)
                      (let ((rate (/ (+ (aref b i) (* (aref bparams i) mu-lo))
                                     (aref acol i))))
                        (when (< rate rowmin)
                          (setq row i
                                rowmin rate)))))
                  (unless row
                    (error "Pivot not found in column ~A." acol))
                  (dotimes (j n)
                    (setf (aref arow j) (aref a row j)))
                  (incf obj (%pivot row col a b c arow acol dict bparams cparams)))))))
      (multiple-value-bind (res-primal res-dual) (%restore b c dict)
        (values obj res-primal res-dual)))))
