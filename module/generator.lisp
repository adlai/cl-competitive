(defpackage :cp/generator
  (:use :cl)
  (:export #:calc-generator))
(in-package :cp/generator)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defun %mod-power (base power modulus)
    (declare ((integer 0 #.most-positive-fixnum) modulus power)
             (integer base))
    (let ((base (mod base modulus))
          (res (mod 1 modulus)))
      (declare ((integer 0 #.most-positive-fixnum) base res))
      (loop while (> power 0)
            when (oddp power)
            do (setq res (mod (* res base) modulus))
            do (setq base (mod (* base base) modulus)
                     power (ash power -1)))
      res))
  (defun calc-generator (modulus &optional start)
    "Searches a generator (starting at START, in ascending order)
w.r.t. MODULUS. MODULUS must be prime."
    (declare ((integer 3 #.most-positive-fixnum) modulus)
             ((or null (integer 2 #.most-positive-fixnum)) start))
    (let ((start (or start 2)))
      (assert (and (> modulus start) (oddp modulus)))
      (let ((divs (make-array 20 :element-type '(integer 0 #.most-positive-fixnum)))
            (end 1)
            (x (floor (- modulus 1) 2)))
        (declare ((integer 0 #.most-positive-fixnum) x))
        (setf (aref divs 0) 2)
        (loop while (evenp x)
              do (setq x (floor x 2)))
        (loop for i of-type (integer 0 #.most-positive-fixnum) from 3 by 2
              while (<= (* i i) x)
              when (zerop (mod x i))
              do (setf (aref divs end) i)
                 (incf end)
                 (loop while (zerop (mod x i))
                       do (setq x (floor x i))))
        (when (> x 1)
          (setf (aref divs end) x)
          (incf end))
        (loop for g of-type (integer 0 #.most-positive-fixnum) from start
              do (dotimes (i end (return-from calc-generator g))
                   (when (= 1 (%mod-power g (floor (- modulus 1) (aref divs i)) modulus))
                     (return))))))))
