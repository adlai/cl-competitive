;;;
;;; Fast Number Theoretic Transform
;;; Reference: https://kopricky.github.io/code/FFTs/ntt.html
;;;

(defconstant +ntt-mod+ 998244353)
(defconstant +ntt-root+ 3)
(deftype ntt-int () '(unsigned-byte 31))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (assert (typep +ntt-mod+ 'ntt-int)))

(declaim (inline power2-p))
(defun power2-p (x)
  "Returns true iff X is a power of 2."
  (zerop (logand x (- x 1))))

(declaim (ftype (function * (values (simple-array ntt-int (*)) &optional)) ntt!))
(defun ntt! (vector &optional inverse)
  (declare (optimize (speed 3))
           (vector vector))
  (labels ((mod* (x y)
             (declare (ntt-int x y))
             (mod (* x y) +ntt-mod+))
           (mod+ (x y)
             (declare (ntt-int x y))
             (let ((res (+ x y)))
               (if (>= res +ntt-mod+)
                   (- res +ntt-mod+)
                   res)))
           (mod- (x y)
             (declare (ntt-int x y))
             (mod+ x (- +ntt-mod+ y)))
           (mod-power (base exp)
             (declare (ntt-int base)
                      ((integer 0 #.most-positive-fixnum) exp))
             (let ((res 1))
               (declare (ntt-int res))
               (loop while (> exp 0)
                     when (oddp exp)
                     do (setq res (mod* res base))
                     do (setq base (mod* base base)
                              exp (ash exp -1)))
               res))
           (mod-inverse (x)
             (mod-power x (- +ntt-mod+ 2))))
    (let* ((vector (coerce vector '(simple-array ntt-int (*))))
           (len (length vector))
           (roots (make-array (+ 1 (ash len -1)) :element-type 'ntt-int :initial-element 1))
           (tmp (make-array len :element-type 'ntt-int)))
      (declare ((simple-array ntt-int (*)) vector tmp)
               (ntt-int len))
      (assert (power2-p len))
      (when (<= len 1)
        (return-from ntt! vector))
      (let ((root (mod-power +ntt-root+
                              (if inverse
                                  (- +ntt-mod+ 1 (floor (- +ntt-mod+ 1) len))
                                  (floor (- +ntt-mod+ 1) len)))))
        (dotimes (i (ash len -1))
          (setf (aref roots (+ i 1))
                (mod* (aref roots i) root))))
      (loop for i of-type ntt-int = 1 then (ash i 1)
            for l of-type ntt-int = (ash len -1) then (ash l -1)
            while (< i len)
            do (loop for j from 0 below l
                     for r of-type ntt-int = 0 then (+ r i)
                     do (loop for k below i
                              for root = (aref roots (* i j))
                              for p = (aref vector (+ k r))
                              for q = (aref vector (+ k r (ash len -1)))
                              do (setf (aref tmp (+ k (* 2 r)))
                                       (mod+ p q)
                                       (aref tmp (+ k (* 2 r) i))
                                       (mod* (mod- p q) root))))
               (rotatef vector tmp))
      (when inverse
        (let ((inv (mod-inverse len)))
          (dotimes (i len)
            (setf (aref vector i) (mod* (aref vector i) inv)))))
      vector)))

(defun ntt-convolute! (vector1 vector2)
  (declare (vector vector1 vector2))
  (assert (= (length vector1) (length vector2)))
  (let* ((len (length vector1))
         (vector1 (ntt! vector1))
         (vector2 (ntt! vector2))
         (res (make-array len :element-type 'ntt-int)))
    (dotimes (i len)
      (setf (aref res i)
            (mod (* (aref vector1 i) (aref vector2 i)) +ntt-mod+)))
    (ntt! res t)))
