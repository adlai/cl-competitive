;;;
;;; Fast Number Theoretic Transform
;;; Reference: https://kopricky.github.io/code/FFTs/ntt.html
;;;

(defconstant +ntt-mod+ 998244353)
(defconstant +ntt-root+ 3)
(deftype ntt-int () '(unsigned-byte 31))
(deftype ntt-vector () '(simple-array ntt-int (*)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (assert (typep +ntt-mod+ 'ntt-int)))

;; FIXME: Here I resort to SBCL's behaviour. Actually ADJUST-ARRAY isn't
;; guaranteed to preserve the given VECTOR.
(declaim (ftype (function * (values ntt-vector &optional)) %adjust-array))
(defun %adjust-array (vector length)
  (declare (vector vector))
  (let ((vector (coerce vector 'ntt-vector)))
    (if (= (length vector) length)
        (copy-seq vector)
        (adjust-array vector length :initial-element 0))))

(declaim (ftype (function * (values ntt-vector &optional)) ntt!))
(defun ntt! (vector &optional inverse)
  (declare (optimize (speed 3))
           (vector vector))
  (labels ((power2-p (x)
             "Returns true iff X is a power of 2"
             (zerop (logand x (- x 1))))
           (mod* (x y)
             (declare (ntt-int x y))
             (mod (* x y) +ntt-mod+))
           (mod+ (x y)
             (declare (ntt-int x y))
             (let ((res (+ x y)))
               (if (>= res +ntt-mod+)
                   (- res +ntt-mod+)
                   res)))
           (mod- (x y)
             (declare (ntt-int x y))
             (mod+ x (- +ntt-mod+ y)))
           (mod-power (base exp)
             (declare (ntt-int base)
                      ((integer 0 #.most-positive-fixnum) exp))
             (let ((res 1))
               (declare (ntt-int res))
               (loop while (> exp 0)
                     when (oddp exp)
                     do (setq res (mod* res base))
                     do (setq base (mod* base base)
                              exp (ash exp -1)))
               res))
           (mod-inverse (x)
             (mod-power x (- +ntt-mod+ 2))))
    (declare (inline mod* mod+ mod-))
    (let ((len (length vector)))
      (assert (power2-p len))
      (check-type len ntt-int))
    (let* ((vector (coerce vector 'ntt-vector))
           (len (length vector))
           (roots (make-array (+ 1 (ash len -1)) :element-type 'ntt-int :initial-element 1))
           (tmp (make-array len :element-type 'ntt-int)))
      (declare ((simple-array ntt-int (*)) vector tmp)
               (ntt-int len))
      (when (<= len 1)
        (return-from ntt! vector))
      (let ((root (mod-power +ntt-root+
                              (if inverse
                                  (- +ntt-mod+ 1 (floor (- +ntt-mod+ 1) len))
                                  (floor (- +ntt-mod+ 1) len)))))
        (dotimes (i (ash len -1))
          (setf (aref roots (+ i 1))
                (mod* (aref roots i) root))))
      (loop for i of-type ntt-int = 1 then (ash i 1)
            for l of-type ntt-int = (ash len -1) then (ash l -1)
            while (< i len)
            do (loop for j from 0 below l
                     for r of-type ntt-int = 0 then (+ r i)
                     do (loop for k below i
                              for root = (aref roots (* i j))
                              for p = (aref vector (+ k r))
                              for q = (aref vector (+ k r (ash len -1)))
                              do (setf (aref tmp (+ k (* 2 r)))
                                       (mod+ p q)
                                       (aref tmp (+ k (* 2 r) i))
                                       (mod* (mod- p q) root))))
               (rotatef vector tmp))
      (when inverse
        (let ((inv (mod-inverse len)))
          (dotimes (i len)
            (setf (aref vector i) (mod* (aref vector i) inv)))))
      vector)))

(declaim (ftype (function * (values ntt-vector &optional)) ntt-convolute))
(defun ntt-convolute (vector1 vector2 &optional fixed)
  (declare (optimize (speed 3))
           (vector vector1 vector2))
  (let ((len1 (length vector1))
        (len2 (length vector1)))
    (when fixed
      (assert (= len1 len2)))
    (let* ((mul-len (max 0 (- (+ len1 len2) 1)))
           ;; power of two ceiling
           (required-len (if fixed
                             len1
                             (ash 1 (integer-length (max 0 (- mul-len 1))))))
           (vector1 (ntt! (%adjust-array vector1 required-len)))
           (vector2 (ntt! (%adjust-array vector2 required-len)))
           (res (make-array required-len :element-type 'ntt-int :initial-element 0)))
      (dotimes (i required-len)
        (setf (aref res i)
              (mod (* (aref vector1 i) (aref vector2 i)) +ntt-mod+)))
      (ntt! res t))))
